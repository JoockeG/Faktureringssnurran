(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['../wrapper', 'should'], factory);
  } else if (typeof exports !== "undefined") {
    factory(require('../wrapper'), require('should'));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.wrapper, global.should);
    global.props = mod.exports;
  }
})(this, function (_wrapper, _should) {
  'use strict';

  var _wrapper2 = _interopRequireDefault(_wrapper);

  var _should2 = _interopRequireDefault(_should);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  var Assertion = _should2.default.Assertion;

  Assertion.add('props', function (expectedKeyValues) {
    if (expectedKeyValues == null || (typeof expectedKeyValues === 'undefined' ? 'undefined' : _typeof(expectedKeyValues)) != 'object') throw new Error('An object needs to be passed in to assert props');

    var wrapper = (0, _wrapper2.default)(this.obj),
        props = wrapper.props(Object.keys(expectedKeyValues));

    this.params = {
      actual: wrapper.name(),
      operator: 'to have ' + formatProps(expectedKeyValues) + ' but found ' + formatProps(props)
    };

    (0, _should2.default)(expectedKeyValues).deepEqual(props, ' ');
  });

  function formatProps(props) {
    return _should2.default.format(props).replace('Object', 'props');
  }
});