'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _babelTypes = require('babel-types');

var t = _interopRequireWildcard(_babelTypes);

var _utils = require('../utils');

var _errors = require('../errors');

var _defaults = require('../defaults');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MSGID = _defaults.PO_PRIMITIVES.MSGID,
    MSGSTR = _defaults.PO_PRIMITIVES.MSGSTR;

var NAME = 'fn-gettext';

function validateArgument(arg) {
    if (!t.isLiteral(arg)) {
        throw new _errors.ValidationError('You can not use ' + arg.type + ' \'' + (0, _utils.ast2Str)(arg) + '\' as an argument to gettext');
    }
    if (arg.type === 'TemplateLiteral') {
        throw new _errors.ValidationError('You can not use template literal as an argument to gettext');
    }
    if (arg.value === '') {
        throw new _errors.ValidationError('You can not pass empty string to gettext');
    }
}

var validate = function validate(path) {
    validateArgument(path.node.arguments[0]);
};

function extract(path) {
    var _ref;

    var node = path.node;
    var msgid = node.arguments[0].value;

    return _ref = {}, _defineProperty(_ref, MSGID, msgid), _defineProperty(_ref, MSGSTR, ''), _ref;
}

function match(_ref2, config) {
    var node = _ref2.node;

    return t.isCallExpression(node) && t.isIdentifier(node.callee) && node.callee.name === config.getAliasFor(NAME) && node.arguments.length > 0;
}

function resolveDefault(nodePath) {
    return nodePath.replaceWith(nodePath.node.arguments[0]);
}

function resolve(path, poData, config) {
    var translations = poData.translations;
    var node = path.node;
    var msgid = node.arguments[0].value;

    var translationObj = translations[msgid];

    if (!translationObj) {
        throw new _errors.NoTranslationError('No "' + msgid + '" in "' + config.getPoFilePath() + '" file');
    }

    var transStr = translationObj[MSGSTR][0];
    if (!transStr.length) {
        throw new _errors.NoTranslationError('No translation for "' + msgid + '" in "' + config.getPoFilePath() + '" file');
    }

    path.replaceWith(t.stringLiteral(transStr));
}

exports.default = { match: match, extract: extract, resolve: resolve, resolveDefault: resolveDefault, validate: validate, name: NAME };