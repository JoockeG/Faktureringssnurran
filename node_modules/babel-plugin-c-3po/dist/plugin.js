'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function () {
    var context = void 0;
    var disabledScopes = new Set();
    var potEntries = [];
    var aliases = {};
    var imports = new Set();

    function extractOrResolve(nodePath, state) {
        if (nodePath.node._C3PO_visited) {
            // Should visit each node only once
            return;
        }
        if ((0, _utils.isInDisabledScope)(nodePath, disabledScopes)) {
            return;
        }

        if (!context) {
            context = new _context2.default(state.opts);
        }
        context.setAliases(aliases);
        context.setImports(imports);

        var extractor = (0, _extract.getExtractor)(nodePath, context);
        if (!extractor) {
            return;
        }

        var alias = context.getAliasFor(extractor.name);

        if (!context.hasImport(alias)) {
            return;
        }

        try {
            try {
                extractor.validate(nodePath.node, context);
            } catch (err) {
                if (err instanceof _errors.ValidationError) {
                    context.validationFailureAction(extractor.name, err.message);
                    return;
                }
                throw err;
            }

            if (context.isExtractMode()) {
                var poEntry = (0, _extract.extractPoEntry)(extractor, nodePath, context, state);
                poEntry && potEntries.push(poEntry);
            }

            if (context.isResolveMode()) {
                (0, _resolve.resolveEntries)(extractor, nodePath, context, state);
            }
            nodePath.node._C3PO_visited = true;
        } catch (err) {
            // TODO: handle specific instances of errors
            throw nodePath.buildCodeFrameError(err.message);
        }
    }

    return {
        post: function post() {
            if (context && context.isExtractMode() && potEntries.length) {
                (function () {
                    var poData = (0, _poHelpers.buildPotData)(potEntries);

                    // Here we sort reference entries, this could be useful
                    // with conf. options extract.location: 'file' and sortByMsgid
                    // which simplifies merge of .po files from different
                    // branches of SCM such as git or mercurial.
                    var poEntries = poData.translations.context;
                    Object.keys(poEntries).forEach(function (k) {
                        var poEntry = poEntries[k];
                        // poEntry has a form:
                        // {
                        //     msgid: 'message identifier',
                        //     msgstr: 'translation string',
                        //     comments: {
                        //         reference: 'path/to/file.js:line_number\npath/to/other/file.js:line_number'
                        //     }
                        // }
                        if (poEntry.comments && poEntry.comments.reference) {
                            poEntry.comments.reference = poEntry.comments.reference.split('\n').sort(_utils.poReferenceComparator).join('\n');
                        }
                    });

                    if (context.isSortedByMsgid()) {
                        (function () {
                            var oldPoData = poData.translations.context;
                            var newContext = {};
                            var keys = Object.keys(oldPoData).sort();
                            keys.forEach(function (k) {
                                newContext[k] = oldPoData[k];
                            });
                            poData.translations.context = newContext;
                        })();
                    }
                    var potStr = (0, _poHelpers.makePotStr)(poData);
                    var filepath = context.getOutputFilepath();
                    var dirPath = _path2.default.dirname(filepath);
                    _mkdirp2.default.sync(dirPath);
                    _fs2.default.writeFileSync(filepath, potStr);
                })();
            }
        },

        visitor: {
            TaggedTemplateExpression: extractOrResolve,
            CallExpression: extractOrResolve,
            Program: function Program(nodePath) {
                disabledScopes = new Set();
                aliases = {};
                imports = new Set();
                if ((0, _utils.hasDisablingComment)(nodePath.node)) {
                    disabledScopes.add(nodePath.scope.uid);
                }
            },
            BlockStatement: function BlockStatement(nodePath) {
                if ((0, _utils.hasDisablingComment)(nodePath.node)) {
                    disabledScopes.add(nodePath.scope.uid);
                }
            },
            ImportDeclaration: function ImportDeclaration(nodePath) {
                var node = nodePath.node;

                if ((0, _utils.isC3poImport)(node)) {
                    node.specifiers.filter(function (_ref) {
                        var name = _ref.local.name;
                        return reverseAliases[name];
                    }).map(function (s) {
                        return imports.add(s.local.name);
                    });
                }
                if ((0, _utils.isC3poImport)(node) && (0, _utils.hasImportSpecifier)(node)) {
                    node.specifiers.filter(function (s) {
                        return s.type === 'ImportSpecifier';
                    }).filter(function (_ref2) {
                        var name = _ref2.imported.name;
                        return reverseAliases[name];
                    }).forEach(function (_ref3) {
                        var imported = _ref3.imported,
                            local = _ref3.local;

                        aliases[reverseAliases[imported.name]] = local.name;
                        imports.add(local.name);
                    });
                }
            }
        }
    };
};

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _context = require('./context');

var _context2 = _interopRequireDefault(_context);

var _extract = require('./extract');

var _resolve = require('./resolve');

var _poHelpers = require('./po-helpers');

var _utils = require('./utils');

var _defaults = require('./defaults');

var _errors = require('./errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var reverseAliases = {};
var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
    for (var _iterator = Object.keys(_defaults.ALIASES)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;

        reverseAliases[_defaults.ALIASES[key]] = key;
    }
} catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
} finally {
    try {
        if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
        }
    } finally {
        if (_didIteratorError) {
            throw _iteratorError;
        }
    }
}