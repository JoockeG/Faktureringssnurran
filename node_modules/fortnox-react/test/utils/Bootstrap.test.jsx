import Bootstrap from 'utils/Bootstrap';
import sinon from 'sinon';
import should from 'should';
describe('Bootstrap', () => {
	let sessionStorageMock, stub;
	const user = {
		name: 'john doe'
	};

	beforeEach(() => {
		sessionStorageMock = {};
		stub = sinon.stub(Bootstrap, 'saveToSession', (key, value) => {
			sessionStorageMock[key] = value;
		});
	});

	afterEach(() => {
		stub.restore();
	});

	describe('save response to session storage', () => {

		it('shall save features to session storage', () => {
			Bootstrap.handleResponse(user, [], ['feature']);
			const features = sessionStorageMock['features'];
			features.should.be.a.Array().and.have.lengthOf(1);
		});

		it('shall save empty list of rights when no values are given', () => {
			Bootstrap.handleResponse();
			const currentUserRights = sessionStorageMock['currentUserRights'];
			currentUserRights.should.be.a.Array().and.have.lengthOf(0);
		});

		it('shall return the user in the response', () => {
			const userResponse = Bootstrap.handleResponse(user, [], null);
			userResponse.name.should.equal('john doe');
		});

		it('shall not return rights object from the user-endpoint', () => {
			const userResponse = Bootstrap.handleResponse(user, [], null);
			should.not.exist(userResponse.rights);
		});

	});

	describe('retry logic ', function () {

		describe('when fetching users or rights fails', function () {

			let fetch, retryConfig, redirectToLogin;
			beforeEach(() => {
				fetch = sinon.stub(Bootstrap, 'fetch', () => new Promise((resolve, reject) => reject({
					status:500
				})));
				retryConfig = sinon.stub(Bootstrap, 'retryConfig', () => {
					return {retries: 3, minTimeout: 1, factor: 1}
				});
				redirectToLogin = sinon.stub(Bootstrap, 'redirectToLogin', () => {
				});
			});

			afterEach(() => {
				fetch.restore();
				retryConfig.restore();
				redirectToLogin.restore();
			});

			it('shall call unauthorized handler when 4 failed attempts to load rights has been made', () => {
				return Bootstrap.loadData().then(() => {
					sinon.assert.fail('catch should be called')
				}).catch(() => {
					fetch.callCount.should.equal(4);
					redirectToLogin.called.should.equal(true);
				});

			});

		});

		describe('server returns unauthorized', function () {

	        let fetch, retryConfig, redirectToLogin;
	        beforeEach(() => {
	            fetch = sinon.stub(Bootstrap, 'fetch', () => new Promise((resolve, reject) => reject({
	                status:401
	            })));
	            retryConfig = sinon.stub(Bootstrap, 'retryConfig', () => {
	                return {retries: 3, minTimeout: 1, factor: 1}
	            });
	            redirectToLogin = sinon.stub(Bootstrap, 'redirectToLogin', () => {});
	        });

	        afterEach(() => {
	            fetch.restore();
	            retryConfig.restore();
	            redirectToLogin.restore();
	        });

	        it('shall redirect to login after one atempt', () => {
	            return Bootstrap.loadData().then(() => {
	                sinon.assert.fail('catch should be called')
	            }).catch(() => {
	                fetch.callCount.should.equal(1);
	                redirectToLogin.called.should.equal(true);
	            });

	        });

	    });


		describe('when failure occurs during save of current user rights ', function () {

			let fetch, retryConfig, redirectToLogin;
			beforeEach(() => {
				fetch = sinon.stub(Bootstrap, 'fetch', () => new Promise((resolve) => resolve()));
				retryConfig = sinon.stub(Bootstrap, 'retryConfig', () => {
					return {retries: 3, minTimeout: 1, factor: 1}
				});
				retryConfig = sinon.stub(Bootstrap, 'handleResponse', () => {
					throw 'failure'
				});
				redirectToLogin = sinon.stub(Bootstrap, 'redirectToLogin', () => {
				});
			});

			afterEach(() => {
				fetch.restore();
				retryConfig.restore();
				redirectToLogin.restore();
			});

			it('shall call unauthorized handler when  failure occurs during handle of the response ', () => {
				return Bootstrap.loadData().then(() => {
					sinon.assert.fail('catch should be called')
				}).catch(() => {
					fetch.callCount.should.equal(1);
					redirectToLogin.called.should.equal(true);
				});
			});

		});
	})

});
