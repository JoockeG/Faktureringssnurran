import React from 'react';
import ReactDOM from 'react-dom';
import TestUtils from 'react-dom/test-utils';
import Backbone from 'utils/BackboneAdapter';
import 'utils/AjaxStub'
import should from 'should';

import FieldText from 'form/TextBox';
import FieldNumeric from 'form/Numeric';
import FieldMoney from 'form/Money';

describe('Form Field Validation', () => {

	it('Uses validate:prop event', done => {
		const airplane = new Backbone.Model();
		airplane.on('validate:prop', () => {
			should.ok('Validate prop triggered');
			done();
		});

		airplane.hasInvalidProps().should.be.false();
		airplane.getInvalidProps().should.containDeep([]);
		airplane.setInvalidProp('someKey').should.containDeep(['someKey']);
		//Setting same key twice should not yield double entries
		airplane.setInvalidProp('someKey').should.containDeep(['someKey']);
		airplane.unsetInvalidProp('someKey').should.containDeep([]);
		airplane.validateProps();
	});


	it('Should update the isValid state depending on changes done to the field', done => {
		const m = new Backbone.Model({Â price: 10 });
		const component = TestUtils.renderIntoDocument(
			<FieldNumeric model={m} modelProp="price" />
		);
		const input = TestUtils.findRenderedDOMComponentWithTag(component, 'input');

		//Note here we use FieldText as type instead of FieldNumeric when looking
		//for the component, this is because internally all fields uses FieldText.
		TestUtils.findRenderedComponentWithType(component, FieldText).state.isValid.should.be.true();
		input.value = 'S';
		TestUtils.Simulate.change(ReactDOM.findDOMNode(input));
		TestUtils.Simulate.blur(ReactDOM.findDOMNode(input));
		m.validateProps();
		TestUtils.findRenderedComponentWithType(component, FieldText).state.isValid.should.be.false();
		input.value = '99';
		TestUtils.Simulate.change(ReactDOM.findDOMNode(input));
		TestUtils.Simulate.blur(ReactDOM.findDOMNode(input));
		m.validateProps();
		TestUtils.findRenderedComponentWithType(component, FieldText).state.isValid.should.be.true();
		done();
	});


	it('Should validate required fields', done => {
		const m = new Backbone.Model();
		const component = TestUtils.renderIntoDocument(
			<FieldText model={m} modelProp="name" required />
		);
		const input = TestUtils.findRenderedDOMComponentWithTag(component, 'input');
		TestUtils.findRenderedComponentWithType(component, FieldText).state.isValid.should.be.true();
		TestUtils.Simulate.change(ReactDOM.findDOMNode(input));
		TestUtils.Simulate.blur(ReactDOM.findDOMNode(input));
		//Bluring the field, leaving it empty sets it in invalid state:
		TestUtils.findRenderedComponentWithType(component, FieldText).state.isValid.should.be.false();
		done();
	});


	it('Should reset invalid props when fields are empty', done => {
		const M = Backbone.Model.extend({
			validators:{
				money(value){
					return value < 10 ? true : 'Error';
				}
			}
		});
		const moneys = new M();
		const component = TestUtils.renderIntoDocument(
			<FieldMoney model={moneys} modelProp="test" validator="money" />
		);
		const input = TestUtils.findRenderedDOMComponentWithTag(component, 'input');
		input.value = 15;

		TestUtils.Simulate.change(input);
		TestUtils.Simulate.blur(input);

		moneys.hasInvalidProps().should.be.true();

		input.value = '';

		TestUtils.Simulate.change(input);
		TestUtils.Simulate.blur(input);

		moneys.hasInvalidProps().should.be.false();
		done();
	});



});
