import React from 'react';
import 'should';
import sinon from 'sinon';
import { mount } from 'enzyme';

import Backbone from 'utils/BackboneAdapter';
import Reports from 'utils/ReportsButton';
import AppContainer from 'utils/AppContainer';


describe('Reports button', () => {
	const sandbox = sinon.sandbox.create();

	beforeEach(() => {
		sandbox.stub(AppContainer, 'isFramedContext').withArgs().returns(true);
	});

	afterEach(() => {
		sandbox.restore();
	});

	it('Uses postMessage on click', (done) => {
		const collectionUnderTest = new (Backbone.Collection.extend({}))([{ dummy: 'data' }]);
		const fetchMock = sandbox.mock(collectionUnderTest, 'fetch');
		fetchMock.expects('fetch').once().withArgs().returns(Promise.resolve());

		sandbox.stub(window.parent, 'postMessage', (...args) => {
			args[0].should.eql({ type: 'open-reports-v1' });
			args[1].should.eql('*');
			done();
		});

		const wrapper = mount(<Reports collection={collectionUnderTest} eventbus={{}} />);
		setTimeout(() => {
			wrapper.find('a').simulate('click');
		}, 10);
	});

	it('Publishes a message on the eventbus on errors', (done) => {
		const collectionUnderTest = new (Backbone.Collection.extend({}))();
		const fetchMock = sandbox.mock(collectionUnderTest, 'fetch');
		fetchMock.expects('fetch').once().withArgs().returns(Promise.reject());

		const eventbusUnderTest = {
			trigger: (...args) => {
				fetchMock.verify();
				args[0].should.equal('message:action');
				args[1].should.equal('Rapporter är för närvarande inte tillgängliga. Försök igen senare.');
				done();
			}
		};

		const wrapper = mount(
			<Reports collection={collectionUnderTest} eventbus={eventbusUnderTest} />
		);
		setTimeout(() => {
			wrapper.find('a').simulate('click');
		}, 10);
	});
});
