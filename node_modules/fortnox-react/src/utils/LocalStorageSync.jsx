import React from 'react';
import PropTypes from 'prop-types';
import { t as gettext } from 'c-3po';
import Dialog from './Dialog';
import Button from '../form/Button';
import Backbone from './BackboneAdapter';
import Row from '../flexbox/Row';
import Column from '../flexbox/Column';
import devdebug from './DevDebug';
import customPropValidation from './PropValidation';

const LSEXCEPTION = '[LocalStorageSync] An error occured while syncing with localstorage. Running in private browsing mode?';

class LocalStorageSync extends React.Component {

	/**
	 * Show the dialog if there is data in localStorage.
	 * @param  {Object} props
	 * @return {undefined}
	 */
	constructor(props) {
		super(props);
		this.state = {
			shouldShowDialog: this.hasLocalStorageData()
		};
	}

	/**
	 * The sync event is triggered inside backbone when a model or collection has been in "contact"
	 * with the server(s)/backend, at least made a request and got a successfull response.
	 * @return {undefined}
	 */
	componentDidMount() {
		this.getInstanceKeys().forEach((key) => {
			this.props.config[key].on('change', () => this.sync(this.props.config[key], key), this);
		});
		this.props.invalidateWhenSaving.on('sync', this.clearLocalStorage, this);
	}

	/**
	 * Disable all events from "this" context.
	 * This is needed since we bind the event to a lambda using arrow
	 * function in the above method, hence we have no reference to the real method.
	 * Otherwise we could point to a specific function-reference instead of "null".
	 *
	 * @return {undefined}
	 */
	componentWillUnmount() {
		this.getInstanceKeys().forEach((key) => {
			this.props.config[key].off(null, null, this);
		});
		this.props.invalidateWhenSaving.off('sync', this.clearLocalStorage, this);
	}

	getViewLocationID() {
		// TODO Notice, this should return location path when we switch to HTML5 History API
		return location.hash.split('?')[0];
	}

	/**
	 * Generate key for localStorage. Needs to be identified using the view
	 * route together with dbid and userid.
	 * @param  {String} key
	 * @return {String}
	 */
	getLocalStorageKeyString(key) {
		return [this.getViewLocationID(), this.props.uHash, key].join(':');
	}

	/**
	 * Convert keys of model/collection instances to the appropriate prefix
	 * used as the localStorage key.
	 * @return {Array}
	 */
	getLocalStorageKeys() {
		return this.getInstanceKeys().map(key => this.getLocalStorageKeyString(key));
	}

	getInstanceKeys() {
		return Object.keys(this.props.config);
	}

	/**
	 * Convert the model-object attributes to a json string
	 * because you can only save string data in localStorage.
	 * @param  {Backbone.Model|Backbone.collection} instance
	 * @return {String}
	 */
	getLocalStorageJSONString(instance) {
		return JSON.stringify(instance.toJSON());
	}

	hasLocalStorageData() {
		return this.getLocalStorageKeys().filter(key => localStorage.getItem(key) !== null).length > 0;
	}

	/**
	 * Determine if we should use set or reset depending on
	 * wether the instance is a model or collection.
	 * @param  {Backbone.Model|Backbone.Collection} instance
	 * @return {String}
	 */
	getBackboneMethod(instance) {
		return (instance instanceof Backbone.Model) ? 'set' : 'reset';
	}

	/**
	 * Load data from localStorage and set it on each model/collection.
	 * Uses "set" on models and "reset" on collections. The "set" method on
	 * collections merges data and is very error-prone.
	 *
	 * The dialog should close even if there is no data present, since the user
	 * could press "save" before closing the dialog.
	 * @return {String}
	 */
	setBackboneData() {
		this.setState({ shouldShowDialog: false });
		if (!this.hasLocalStorageData()) { return; }
		let lsKey;
		let data;
		let method;

		this.getInstanceKeys().forEach((key) => {
			lsKey = this.getLocalStorageKeyString(key);
			data = JSON.parse(localStorage.getItem(lsKey));
			method = this.getBackboneMethod(this.props.config[key]);
			this.props.config[key][method](data);
		});
	}

	sync(instance, key) {
		const localStorageKey = this.getLocalStorageKeyString(key);
		const json = this.getLocalStorageJSONString(instance);
		const data = {};
		data[localStorageKey] = json;

		try {
			localStorage.setItem(localStorageKey, json);
		} catch (e) {
			devdebug(LSEXCEPTION);
		}

		return this.props.onSync(data);
	}

	clearLocalStorage() {
		this.setState({ shouldShowDialog: false });
		if (!this.hasLocalStorageData()) { return; }

		this.getLocalStorageKeys().forEach((key) => {
			localStorage.removeItem(key);
		});
	}

	render() {
		return (
			<div>
				<Dialog
					width="300" height="130" title="-"
					isOpen={this.state.shouldShowDialog} blockViewport
				>
					{gettext`Det finns osparade förändringar. Vill du fortsätta arbeta med dessa?`}
					<Row>
						<Column width="0">
							<Button onClick={this.clearLocalStorage.bind(this)}>{gettext`Nej`}</Button>
						</Column>
						<Column width="0">
							<Button color="green" onClick={this.setBackboneData.bind(this)}>{gettext`Ja`}</Button>
						</Column>
					</Row>
				</Dialog>
			</div>
		);
	}
}


LocalStorageSync.propTypes = {
	config: PropTypes.object.isRequired,
	onSync: PropTypes.func,
	uHash: PropTypes.string.isRequired,
	invalidateWhenSaving: customPropValidation.model.isRequired
};

LocalStorageSync.defaultProps = {
	onSync(data) {
		return data;
	}
};

export default LocalStorageSync;
