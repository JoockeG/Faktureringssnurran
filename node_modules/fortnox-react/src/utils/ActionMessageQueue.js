import Backbone from './BackboneAdapter';

/**
 * Message model
 * Automatically destroy the model when the ttl has passed.
 *
 * @class
 * @name Message
 *
 * @return {Message} An instance of the Message model.
 */
const Message = Backbone.Model.extend({

	/**
	 * @memberOf Message
	 * @private
	 *
	 * @description
	 * Set a timer to remove this message after its time to live runs out.
	 * If ttl is null or nonexistant, then let the message live forever until
	 * the user closes the message explicitly.
	 *
	 * @returns {undefined}
	 */
	initialize() {
		if (this.get('ttl')) {
			this.setTimeToLive(this.get('ttl'));
		}
	},

	/**
	 * @memberOf Message
	 * @private
	 *
	 * @description
	 * Start a timer that will expire the message once its ttl runs out
	 *
	 * @param {number} ttl
	 *
	 * @returns {undefined}
	 */
	setTimeToLive(ttl) {
		setTimeout(this.messageWillExpire.bind(this), ttl);
	},

	/**
	 * @memberOf Message
	 * @private
	 *
	 * @description
	 * Remove the message
	 *
	 * @returns {undefined}
	 */
	messageWillExpire() {
		this.destroy();
	}

});


/**
 * MessageQueue collection
 * Contains all the current messages
 *
 * @class
 * @name MessageQueue
 *
 * @return {MessageQueue} An instance of the Message model.
 */
const MessageQueue = Backbone.Collection.extend({
	model: Message,

	/**
	 * @memberOf MessageQueue
	 * @private
	 *
	 * @description
	 * Setup eventlistener on the eventBus
	 *
	 * @param {Array} models
	 * @param {Object} options
	 *
	 * @returns {undefined}
	 */
	initialize(models, options) {
		this.eventBus = options.eventBus;
		options.eventBus.on('message:action', this.shouldAddMessage, this);
		options.eventBus.on('SERVER.NOTIFICATIONS', this.handleServerMessages, this);
	},

	/**
	 * @memberOf MessageQueue
	 * @private
	 *
	 * @description
	 * Handle messages sent by the server through the SERVER.NOTIFICATIONS event.
	 * In order to be compatible with F3 during a transition period this event can't
	 * be removed, instead the refactored Ajax plugin still uses this event.
	 *
	 * All we do here is simply proxy these events into "real" message events.
	 *
	 * @param {Array} messageTypes - Array containing objects message types
	 * INFO, ERROR, CONFIRM and messages
	 *
	 * @return {Array}
	 */
	handleServerMessages(messageTypes) {
		return Object.keys(messageTypes)
			.map(type => ({
				type,
				messageList: messageTypes[type].map((msg) => {
					this.eventBus.trigger('message:action', msg.body, type.toLowerCase(), 6000);
					return msg.body;
				}, this)
			}), this);
	},

	/**
	 * @memberOf MessageQueue
	 * @private
	 *
	 * @description
	 * Once per event, add a message to the queue
	 *
	 * @param {String} msg - text of message
	 * @param {String} type - define the type of message (error|info|confirm)
	 * @param {number} ttl - Lifetime of the message before its removed
	 *
	 * @returns {undefined}
	 */
	shouldAddMessage(msg, type, ttl) {
		return this.add({ msg, type, ttl });
	}

});

export default MessageQueue;
