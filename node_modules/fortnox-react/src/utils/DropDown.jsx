import React from 'react';
import PropTypes from 'prop-types';
import Flex from '../flexbox/Container';
import AppContainer from './AppContainer';

class DropDown extends React.Component {

	constructor(props) {
		super(props);
		this.state = {
			isVisible: false
		};

		this.ctxOnUserHideDropDown = this.onUserHideDropDown.bind(this);
		this.ctxOnVesselMessage = this.onVesselHideDropDown.bind(this);
	}


	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Add an eventlistener to the document so that we can catch
	 * clicks outside of the dropdown and hide it.
	 *
	 * The ref code looks a little dirty (See constructor), this is because bind creates a new
	 * function reference every time you call it, so in order to be able to remove
	 * the specific function reference (removeEventListener) we have to save
	 * a ref to it.
	 *
	 * @returns {Boolean}
	 */
	componentDidMount() {
		document.addEventListener('message', this.ctxOnVesselMessage);
		document.addEventListener('mouseup', this.ctxOnUserHideDropDown, false);
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Only rerender when props or state.display changes
	 *
	 * @param {Object} nextProps
	 * @param {Object} nextState
	 *
	 * @return {Boolean}
	 */
	shouldComponentUpdate(nextProps, nextState) {
		return this.props !== nextProps || this.state.isVisible !== nextState.isVisible;
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Clean up global event
	 *
	 * @returns {undefined}
	 */
	componentWillUnmount() {
		document.removeEventListener('mouseup', this.ctxOnUserHideDropDown, false);
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Determine if target of event is a li tag
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @returns {Boolean}
	 */
	isValidTag(e) {
		return ['a', 'li'].indexOf(e.target.tagName.toLowerCase()) !== -1;
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Determine if the event happened within the dropdown Container
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @returns {Boolean}
	 */
	isWithinDropDown(e) {
		return this.container.contains(e.target);
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Determine if the event happened within the menu Content
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @returns {Boolean}
	 */
	isWithinDropDownContent(e) {
		return this.menudown.contains(e.target);
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * When clicking somewhere in parent context/vessel, hide open dropdowns.
	 **/
	onVesselHideDropDown(e) {
		const isVessel = AppContainer.isFramedContext() && AppContainer.isVesselEvent(e);
		if (isVessel && e.data.type === 'vessel-click-v1') {
			this.setState({ isVisible: false });
		}
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Whenever we hide the dropdown, make sure we're not clicking
	 * somewhere inside of it. Unless we are clicking on a "li" tag, in
	 * this case hide it, but since events on these "li" tags are "onclick"
	 * this will bubble up properly, since this is a mouseup event.
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @returns {Boolean}
	 */
	onUserHideDropDown(e) {
		if (this.isWithinDropDown(e) && !this.isValidTag(e) && !this.isWithinDropDownContent(e)) {
			return;
		}
		this.setState({ isVisible: false });
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Show the dropdown when we click on the menu title
	 *
	 * @returns {Boolean}
	 */
	onUserMouseDown() {
		this.setState({ isVisible: !this.state.isVisible });
		this.props.onMouseDown();
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Returns an arrow pointing down if specified in props
	 *
	 * @return {Object}
	 */
	getArrow() {
		return this.props.arrow ? <i className="fa fa-caret-down" /> : null;
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Returns a span for the title (Used to invoke dropdown)
	 *
	 * @return {Object}
	 */
	getTitle() {
		const { title } = this.props;
		if (!title) {
			return null;
		}
		return typeof title === 'string' ? <span className="menudown-title">{title}</span> : title;
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Returns an <span> tag with icon, used as a button to invoke the dropdown.
	 *
	 * @return {Object}
	 */
	getIcon() {
		return this.props.icon ?
			<span
				className="menudown-title"
				onMouseDown={this.onUserMouseDown.bind(this)}
			>
				<i className={this.props.icon} />
			</span> : null;
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Return an element serving as a button to invoke the dropdown.
	 * This can be either an icon or a simple span tag with text, or both
	 *
	 * @return {Object}
	 */
	getButton() {
		return (
			<span className="dropdown-btn" onMouseDown={this.onUserMouseDown.bind(this)}>
				{this.getIcon()}
				{this.getTitle()}
				{this.getArrow()}
			</span>
		);
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Generate css class names
	 *
	 * @return {String}
	 */
	getClasses() {
		return [
			'dropdown-container',
			(this.state.isVisible ? ' dropdown-active ' : ''),
			this.props.className
		].join(' ');
	}

	/**
	 * @memberOf DropDown
	 * @private
	 *
	 * @description
	 * Render the dropdown
	 *
	 * @return {Object}
	 */
	render() {
		return (
			<Flex ref={(el) => { this.container = el; }} className={this.getClasses()}>
				{this.getButton()}
				<ul
					ref={(el) => { this.menudown = el; }}
					className="menudown"
					style={Object.assign({}, this.props.dropdownStyle)}
				>
					{this.props.children}
				</ul>
			</Flex>
		);
	}

}

DropDown.defaultProps = {
	className: '',
	arrow: null,
	icon: null,
	title: null,
	onMouseDown: () => null,
	dropdownStyle: {}
};

DropDown.propTypes = {
	children: PropTypes.node.isRequired,
	arrow: PropTypes.bool,
	title: PropTypes.oneOfType([PropTypes.node, PropTypes.string]),
	icon: PropTypes.string,
	className: PropTypes.string,
	onMouseDown: PropTypes.func,
	dropdownStyle: PropTypes.object
};

export default DropDown;
