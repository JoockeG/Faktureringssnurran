import promiseRetry from 'promise-retry';
import { getFid } from './Fid';
import unauthorizedHandler from './UnauthorizedHandler';

class Bootstrap {
	static loadData() {
		return promiseRetry(Bootstrap.retryConfig(),
			retry => Bootstrap.fetch().catch((response) => {
				if (response.status !== 401) {
					retry();
				}
			}), Bootstrap.redirectToLogin)
			.then((data) => {
				const { user, rights, features } = data;
				return Bootstrap.handleResponse(user, rights, features);
			}).catch(Bootstrap.redirectToLogin);
	}

	static fetch() {
		return Promise.all([
			Bootstrap.fetchWithAuth('/api/user/users-v2/me'),
			Bootstrap.fetchWithAuth('/api/user/users-v2/me/rights'),
			Bootstrap.fetchWithAuth('/api/featureswitch/hasfeature-v2/')
		]).then(response => ({
			user: response[0],
			rights: response[1],
			features: response[2]
		}));
	}

	static retryConfig() {
		return { retries: 3, minTimeout: 1000, factor: 2 };
	}

	static redirectToLogin() {
		unauthorizedHandler();
	}

	static validate(response) {
		if (response.status >= 200 && response.status < 300) {
			return response.json();
		}
		return Promise.reject(response);
	}

	static handleResponse(user = {}, rights = [], features = []) {
		Bootstrap.saveToSession('features', features);
		Bootstrap.saveToSession('currentUserRights', rights);
		Bootstrap.saveToSession('currentUser', user);
		return user;
	}
	static saveToSession(key, objectToSave) {
		window.sessionStorage.setItem(key, JSON.stringify(objectToSave));
	}

	static fetchWithAuth(url) {
		return fetch(url, {
			credentials: 'same-origin',
			method: 'GET',
			headers: {
				'X-TOKEN': getFid() || window.sessionStorage.fid
			}
		}).then(response => this.validate(response));
	}
}

export default Bootstrap;
