import Backbone from 'backbone';
import _ from 'underscore';

/*
	Thin adapter around backbone so that we can switch to something
	else in the future (React based apps).
	Extends backbone with some functionality for validation

	This should be reduced to almost nothing in the future. The largest
	dependencies lies in table and ajax components, when we switch ajax
	over to superagent for new React based apps lots of these can be removed

			**DO NOT ADD CODE HERE**
 */

/**
 * @public
 * @memberOf Backbone.Model
 *
 * @description
 *
 * Check is any prop is currently marked invalid. This is
 * done by some of the React components, used later to validate
 * an entire form.
 *
 *
 * @return {Boolean}
 *
 */
Backbone.Model.prototype.hasInvalidProps = function () {
	return this.hasOwnProperty('_invalidProps') && this._invalidProps.length > 0;
};

/**
 * @public
 * @memberOf Backbone.Model
 *
 * @description
 *
 * Returns an array with valid props. Will always be empty if no
 * invalid props exists.
 *
 *
 * @return {Array}
 *
 */
Backbone.Model.prototype.getInvalidProps = function () {
	return this._invalidProps ? this._invalidProps : [];
};

/**
 * @public
 * @memberOf Backbone.Model
 *
 * @description
 *
 * Set a prop as being invalid, only if the prop is not
 * already invalid.
 *
 *
 * @return {Array}
 *
 */
Backbone.Model.prototype.setInvalidProp = function (prop) {
	const iProps = this.getInvalidProps();
	const index = iProps.indexOf(prop);
	if (index === -1) {
		iProps.push(prop);
	}
	this._invalidProps = iProps;
	return this._invalidProps;
};

/**
 * @public
 * @memberOf Backbone.Model
 *
 * @description
 *
 * Set a prop as being invalid, only if the prop is not
 * already invalid.
 *
 *
 * @return {Array}
 *
 */
Backbone.Model.prototype.unsetInvalidProp = function (prop) {
	if (!this.hasInvalidProps()) {
		return [];
	}
	this._invalidProps = this._invalidProps.filter(p => p !== prop);
	return this._invalidProps;
};

/**
 * @public
 * @memberOf Backbone.Model
 *
 * @description
 *
 * Runs a trigger that some components use to show
 * validation messages.
 *
 *
 * @return {Backbone.Model}
 *
 */
Backbone.Model.prototype.validateProps = function (exclude = []) {
	return this.trigger('validate:prop', exclude);
};


// Pagination methods, sets and gets metadata on collections
const pagination = {

	/**
	 * Set the total count of the resultset
	 * @param {integer} count
	 */
	setCount(count) {
		this.__count = parseInt(count, 10);
	},

	/**
	 * Get the total count of the resultset
	 * @return {integer}
	 */
	getCount() {
		return parseInt(this.__count, 10);
	},

	/**
	 * Set the current page number of the collection
	 * @param {integer} n Page number
	 */
	setPageNum(n) {
		this.__page = n;
	},

	/**
	 * Get the current pagenum
	 * @return {integer}
	 */
	getPageNum() {
		return parseInt(this.__page, 10);
	},

	/**
	 * Sets the amount to show per page
	 * @param {integer} n Amount
	 */
	setPerPage(n) {
		this.__perPage = n;
	},

	/**
	 * Get the amount per page
	 * @return {integer}
	 */
	getPerPage() {
		return this.__perPage;
	},

	/**
	 * Get the number of pages in the paging
	 * @return {int} pages
	 */
	getPages() {
		return Math.ceil(this.getCount() / this.getPerPage());
	},

	/**
	 * Are we on the last page?
	 * @return {boolean}
	 */
	isLastPage() {
		return this.getPageNum() === this.getPages();
	},

	/**
	 * Get pagination configuration
	 * @return {object}
	 */
	pagination() {
		return { perpage: this.__perPage, pagenum: this.__page };
	},

	/**
	 * Sets filters to be used when making fetch( GET ) requests to backend
	 * @param {mixed} filter string|array
	 */
	setFilter(filter) {
		this.__filterby = filter;
		this.setPageNum(1);
		this.trigger('filter');
		return this;
	},

	/**
	 * Get current filter(s)
	 * @return {string} string
	 */
	getFilter() {
		if (_.isArray(this.__filterby)) {
			return this.__filterby.join(',');
		}
		return this.__filterby;
	},

	hasPagination() {
		return (!_.isNumber(this.getCount() || this.getCount() < 1));
	},

	getTotalPages() {
		return Math.ceil(this.getCount() / this.getPerPage());
	},

	getCurrentPage() {
		return (this.getPageNum() ||  1);
	},

	getPagination() {
		if (!_.isNumber(this.getCount() || this.getCount() < 1)) {
			return { pages: [] };
		}
		let total = Math.ceil(this.getCount() / this.getPerPage()),
			current = this.getPageNum() || 1,
			start = current,
			end = current,
			maxWidth = 5,
			positions = (total < maxWidth) ? total - 1 : maxWidth - 1,
			pages = [];

		while (positions > 0) {
			if ((start - 1) > 0) {
				start--;
				positions--;
			}
			if (((end + 1) <= total) && positions > 0) {
				end++;
				positions--;
			}
		}

		for (start; start <= end; start++) {
			pages.push({
				pagenum: start,
				curpage: (current === parseInt(start, 10))
			});
		}


		return { pages };
	},

	/**
	 * Sets the search parameter(s) - defaults pagenum to 1 because page X may not exist based on these search params
	 * @param {mixed} searchParams string|array
	 */
	setSearchParams(searchParams) {
		this.setPageNum(1);
		this.__searchParams = searchParams;
	},

	/**
	 * Gets the search parameter(s)
	 */
	getSearchParams() {
		return this.__searchParams;
	},

	/**
	 *
	 */
	unsetSearchParams() {
		delete this.__searchParams;
	}
};


// Extend collections with pagination methods
_.extend(Backbone.Collection.prototype, pagination);


/**
 * Sets the key of which the resultset will be sorted
 * @param {string} key
 */
Backbone.Collection.prototype.setSortKey = function (key) {
	if (_.isString(key) || _.isNumber(key)) {
		this.__sortkey = key;
		this.trigger('sort', key, this);
	}
};

/**
 * Get the sortkey
 * @return {string}
 */
Backbone.Collection.prototype.getSortKey = function () {
	return this.__sortkey;
};


/**
 * Set the sort order asc/desc
 * @param {string} order
 */
Backbone.Collection.prototype.setOrder = function (order) {
	if (order === 'asc' || order === 'desc') {
		this.__order = order;
		this.trigger('order', order, this);
	}
};

/**
 * Get the sort order
 * @return {string}
 */
Backbone.Collection.prototype.getOrder = function () {
	return (this.__order ? this.__order : 'asc');
};


/**
 * Get all available parameters including pagination, sorting and filters
 * @return {object}
 */
Backbone.Collection.prototype.params = function () {
	const params = {
		perpage: this.getPerPage(),
		pagenum: this.getPageNum(),
		sortby: this.getSortKey(),
		filterby: this.getFilter(),
		order: this.getOrder(),
		searchcolumns: this.getSearchColumns()
	};
	if (this.__searchParams) {
		_.defaults(params, _.isObject(this.__searchParams) ? this.__searchParams : { q: this.__searchParams });
	}
	if (this._meta) {
		params.meta = 1;
	}
	return params;
};

Backbone.Collection.prototype.setParams = function (params) {
	if (params) {
		this.setOrder(params.order);
		this.setSortKey(params.sortby);
		this.setPageNum(params.pagenum);
		this.setPerPage(params.perpage);
	}
};


Backbone.Collection.prototype.setSearchColumns = function (columns) {
	this.__searchColumns = columns;
};

Backbone.Collection.prototype.getSearchColumns = function () {
	const searchColumns = (this.__searchColumns ? this.__searchColumns : []);
	return searchColumns;
};

Backbone.Collection.prototype.deleteSearchColumns = function () {
	delete this.__searchColumns;
};


const timeHandling = {

	// Experimental support for caching collections locally, dont use objects in prototype chain
	cache: {

		update(requestUrl) {
			this._pageCache = this._pageCache || {};
			this._pageCache[(requestUrl || 'default')] = { time: this.timestamp(), data: this.toJSON() };
			// TODO Check memory consumption after a few hours, many pages.
		},

		get(requestUrl) {
			return (this._pageCache[(requestUrl || 'default')].data || null);
		}

	},


    /**
     * Sets the current time in timestamp format on the collection
     * @return {mixed} Backbone.Collection | Backbone.Model
     */
	timestamp() {
		this._timestamp = new Date().getTime();
		return this._timestamp;
	},

    /**
     * Return the age of the collection since last the fetch
     * @return {float} Time in miliseconds
     */
	age() {
		return parseFloat(((new Date().getTime() - this._timestamp || 0)).toFixed(2));
	},

    /**
     * Check if the collection is outdated (Older than 1 min, adjust this threshold)
     * @return {Boolean}
     */
	old() {
		return (this.age() > 1);
	}

};


// Extend collections and models with functions for handling time
_.extend(Backbone.Collection.prototype, timeHandling);
_.extend(Backbone.Model.prototype, timeHandling);


Backbone.Model.prototype.dirty = function (status) {
	this.__dirty = status;
};

Backbone.Model.prototype.isDirty = function () {
	return this.__dirty;
};


const metaMethods = {

    /**
     * Placeholder for parsing metadata, override this with your own if you have a custom format for metadata
     * @param  {mixed} data metadata
     * @return {mixed}
     */
	parseMeta(data) {
		return data;
	},

    /**
     * Set metadata related to the model (Saved outside normal properties)
     * This is only used in the ajax response
     * @param {mixed} data
     */
	setMeta(data) {
		this._modelMeta = this.parseMeta(data);
		this.trigger('meta', this._modelMeta);
	},

    /**
     * Get metadata from the model
     * @return {mixed} metadata
     */
	getMeta() {
		return this._modelMeta || false;
	},

    /**
     * Check if a model or collection is ready based on available data
     * @return {Boolean}
     */
	isReady() {
		return this.age() > 0;
	},

	ready(fn, context) {
		let callback;

		if (this.isReady()) {
			fn.call(context, this);
		} else {
			callback = _.bind(fn, context, this);
			this.off('fetched', callback, context).once('fetched', callback, context);
		}
	}
};


// Extend both collections and models with meta methods
_.extend(Backbone.Model.prototype, metaMethods);
_.extend(Backbone.Collection.prototype, metaMethods);


Backbone.Model.prototype.reset = function (key, options) {
	if (key) {
		this.set(key, this.defaults ? this.defaults[key] : undefined, options);
	} else {
		this.clear();
		if (this.defaults) {
			this.set(this.defaults);
		}
	}
};


export default Backbone;
