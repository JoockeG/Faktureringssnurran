import React from 'react';
import PropTypes from 'prop-types';
import { gettext } from 'c-3po';
import moment from './MomentAdapter';
import _ from './UnderscoreAdapter';

/**
 * React datepicker component.
 *
 * @class Datepicker
 */
class Datepicker extends React.Component {

	constructor(props) {
		super(props);
		this.state = {
			year: _.isFinite(this.props.initialYear) ? this.props.initialYear : moment().year(),
			month: _.isFinite(this.props.initialMonth) ? this.props.initialMonth : moment().month()
		};
	}

	/**
	 * Get the date of Easter for the given year. See
	 * http://aa.usno.navy.mil/faq/docs/easter.php for more information about
	 * the algorithm.
	 *
	 * @param {Number} y - Year.
	 * @return {Object} Moment.js instance.
	 */
	getDateOfEaster(y) {
		const f = Math.floor; // No integer division in JavaScript.
		const c = f(y / 100);
		const n = y - 19 * f(y / 19);
		const k = f((c - 17) / 25);
		let i = c - f(c / 4) - f((c - k) / 3) + 19 * n + 15;
		i -= 30 * f(i / 30);
		i -= f(i / 28) * (1 - f(i / 28) * f(29 / (i + 1)) * f((21 - n) / 11));
		let j = y + f(y / 4) + i + 2 - c + f(c / 4);
		j -= 7 * f(j / 7);
		const l = i - j;
		const m = 3 + f((l + 40) / 44);
		const d = l + 28 - 31 * f(m / 4);
		return moment([y, m - 1, d]);
	}

	/**
	 * Get the Swedish Midsummer date for the given year.
	 *
	 * @param {Number} y - Year.
	 * @param {Object} [date] - Date to start looking for a Saturday on. Moment.js instance.
	 * @return {Object} Moment.js instance.
	 */
	getMidsummerDate(y, date = moment([y, 5, 20])) {
		return date.day() === 6 ? date : this.getMidsummerDate(y, date.clone().add(1, 'days'));
	}

	/**
	 * Get the All Saints' Day date for the given year.
	 *
	 * @param {Number} y - Year.
	 * @param {Object} [date] - Date to start looking for a Saturday on. Moment.js instance.
	 * @return {Object} Moment.js instance.
	 */
	getAllSaintsDayDate(y, date = moment([y, 9, 31])) {
		return date.day() === 6 ? date : this.getAllSaintsDayDate(y, date.clone().add(1, 'days'));
	}

	/**
	 * Compare the year, month and date of the given dates and return their
	 * (total) equality.
	 *
	 * @param {Object} a - Moment.js instance.
	 * @param {Object} b - Moment.js instance.
	 * @return {Boolean} true if the dates are equal, otherwise false.
	 */
	isEqualDate(a, b) {
		return a.format('YYYYMMDD') === b.format('YYYYMMDD');
	}

	/**
	 * Check if the given date is a Sunday or not.
	 *
	 * @param {Object} date - Moment.js instance.
	 * @return {Boolean} true if the date is a Sunday, otherwise false.
	 */
	isSunday(date) {
		return date.day() === 0;
	}

	/**
	 * Check if the given date is a fixed, Swedish holiday or not. A fixed
	 * holiday is a holiday which every year falls on the same date
	 * (Christmas Day, for example).
	 *
	 * @param {Object} date - Moment.js instance.
	 * @return {Boolean} true if the date is a fixed holiday, otherwise false.
	 */
	isFixedHoliday(date) {
		return !!_.find(['0101', '0106', '0501', '0606', '1225', '1226'], x => date.format('MMDD') === x);
	}

	/**
	 * Check if the given date is a holiday, relating to the Swedish Easter
	 * (PÃ¥skdagen or Pingstdagen, for example).
	 *
	 * @param {Object} date - Moment.js instance.
	 * @return {Boolean} true if the date is a holiday,
	 * relating to the Swedish Easter, otherwise false.
	 */
	isEaster(date) {
		const easter = this.getDateOfEaster(date.year());
		const hasEaster = _.find([-2, 0, 1, 39, 49], _.bind(days => this.isEqualDate(easter.clone().add(days, 'days'), date), this));
		return !_.isUndefined(hasEaster);
	}

	/**
	 * Check if the given date is the date of the Swedish Midsummer.
	 *
	 * @param {Object} date - Moment.js instance.
	 * @return {Boolean} true if the date is the date of the Swedish Midsummer, otherwise false.
	 */
	isMidsummer(date) {
		return this.isEqualDate(this.getMidsummerDate(date.year()), date);
	}

	/**
	 * Check if the given date is the date of All Saints' Day.
	 *
	 * @param {Object} date - Moment.js instance.
	 * @return {Boolean} true if the date is the date of All Saints' day, otherwise false.
	 */
	isAllSaintsDay(date) {
		return this.isEqualDate(this.getAllSaintsDayDate(date.year()), date);
	}

	/**
	 * Check if the given date is a holiday for the given locale.
	 *
	 * @param {String} locale - Locale to use.
	 * @param {Object} date - Moment.js instance.
	 * @return {Boolean} true if the date is a holiday, otherwise false.
	 */
	isHoliday(locale, date) {
		const predicates = {
			sv: [
				this.isSunday,
				this.isFixedHoliday,
				this.isEaster,
				this.isMidsummer,
				// This would ideally just be "this.isAllSaintsDay". But due to a bug
				// in the implementation of Date in IE10+, we can't run isAllSaintsDay
				// for all dates.
				() => {
					if (date.month() === 11 || (date.month() === 10 && date.date() > 6)) {
						return false;
					}
					return this.isAllSaintsDay(date);
				}
			]
		};
		if (predicates[locale]) {
			return _.any(_.map(predicates[locale], _.bind(fn => fn.call(this, date), this)));
		}
		return false;
	}

	/**
	 * Check if the given date is inside the frame of the current state of the
	 * "year" and "month" attributes.
	 *
	 * @param {Number} year - Year.
	 * @param {Number} month - Month.
	 * @param {Object} date - Moment.js instance.
	 * @return {Boolean} true if the date has the same
	 * year and month as this instance, otherwise false.
	 */
	isOutOfMonth(year, month, date) {
		return date.year() !== year || date.month() !== month;
	}

	/**
	 * Check if the given date is almost a holiday, for the given locale. At the
	 * moment, return true for Saturdays with the Swedish locale. Return false for
	 * all other cases.
	 *
	 * @param {String} locale - Locale to use.
	 * @param {Object} date - Moment.js instance.
	 * @return {Boolean} true if the date is almost a holiday, otherwise false.
	 */
	isSemiHoliday(locale, date) {
		if (locale === 'sv') {
			return date.day() === 6;
		}
		return false;
	}

	/**
	 * Check if the given date is not a holiday and not a semi-holiday, for the
	 * given locale.
	 *
	 * @param {String} locale - Locale to use.
	 * @param {Object} date - Moment.js instance.
	 * @return {Boolean} true if the date is a business day, otherwise false.
	 */
	isBusinessDay(locale, date) {
		return !this.isHoliday(locale, date) && !this.isSemiHoliday(locale, date);
	}

	/**
	 * Get the types of the given date, for the given locale. A type may be
	 * "holiday", "semi-holiday", "out-of-month", "business-day", "today", or
	 * "unselectable".
	 *
	 * If "alterDateTypes" is set on the props, it will be invoked here and
	 * override the suggested date types.
	 *
	 * @param {String} locale - Locale to use.
	 * @param {Number} year - Year.
	 * @param {Number} month - Month.
	 * @param {Object} date - Moment.js instance.
	 * @return {Array<String>} Date types, sorted alphabetically.
	 */
	getDateTypes(locale, year, month, date) {
		const fns = [
			[_.partial(this.isHoliday, locale), 'holiday'],
			[_.partial(this.isSemiHoliday, locale), 'semi-holiday'],
			[_.partial(this.isOutOfMonth, year, month), 'out-of-month'],
			[_.partial(this.isBusinessDay, locale), 'business-day'],
			[_.partial(this.isEqualDate, moment()), 'today']
		];
		const types = _.map(fns, _.bind((fn) => {
			if (fn[0].call(this, date)) { return fn[1]; }
		}, this));
		return _.sortBy(_.compact(this.props.alterDateTypes(types, date)), _.identity);
	}

	/**
	 * Get the first day of the week of the given date, for the given locale.
	 *
	 * @param {String} locale - Locale to use.
	 * @param {Object} date - Moment.js instance.
	 * @return {Object} Moment.js instance.
	 */
	getBeginningOfWeek(locale, date) {
		return date.clone().add(
			date.clone().locale(locale).weekday() * -1,
			'days'
		);
	}

	/**
	 * Get information about the week of the given date, for the given locale. The
	 * given date is the first day of the week for the given locale.
	 *
	 * The information is the week number and the dates of the week, containing
	 * date number and date types.
	 *
	 * @param {String} locale - Locale to use.
	 * @param {Number} year - Year.
	 * @param {Number} month - Month
	 * @param {Object} start - Moment.js instance.
	 * @return {Object} Information about the week for the given date.
	 */
	getWeek(locale, year, month, start) {
		const date = start.clone().locale(locale);
		return {
			number: date.week(),
			dates: _.map(_.range(7), _.bind((n) => {
				const d = date.clone().add(n, 'days');
				return {
					year: d.year(),
					month: d.month(),
					date: d.date(),
					types: this.getDateTypes(locale, year, month, d)
				};
			}, this))
		};
	}

	/**
	 * Get information about the weeks of the current month (determined by the
	 * given year and month). Work greedily, i.e. include all dates in the current
	 * month and out of the month, in joining weeks.
	 *
	 * The number of the returned weeks is eiter 4, 5 or 6, depending on the
	 * length of the month.
	 *
	 * @param {String} locale - Locale to use.
	 * @param {Number} year - Year.
	 * @param {Number} month - Month.
	 * @param {Array<Object>} [weeks] - Weeks determined so far.
	 * @param {Object} [date] - Date to start from. Moment.js instance.
	 * @return {Array<Object>} Information about the weeks of the current month.
	 */
	getWeeks(
		locale,
		year,
		month,
		weeks,
		date = this.getBeginningOfWeek(locale, moment([year, month]).locale(locale))) {
		const week = this.getWeek(locale, year, month, date);
		weeks = (weeks || []).concat([week]);
		if (_.contains(_.last(week.dates).types, 'out-of-month')) {
			return _.filter(weeks, w => _.filter(_.flatten(_.pluck(w.dates, 'types')), t => t === 'out-of-month').length !== 7);
		}
		return this.getWeeks(locale, year, month, weeks, date.clone().add(7, 'days'));
	}

	/**
	 * Memoization of the getWeeks method.
	 *
	 * @param {String} locale - Locale to use.
	 * @param {Number} year - Year.
	 * @param {Number} month - Month.
	 * @return {Array<Object>} Information about the weeks of the current month.
	 */
	getWeeksMemo(locale, year, month) {
		return _.memoize(
			function (locale, year, month) {
				return this.getWeeks(locale, year, month);
			},
			(locale, year, month) => [locale, year, month].join('-')
		).apply(this, [locale, year, month]);
	}

	/**
	 * Get the names of the weekdays, according to the given locale.
	 *
	 * @param {String} locale - Locale to use.
	 * @return {Array<Object>} Array of objects, containing each weekday's name.
	 */
	getWeekdays(locale) {
		return _.map(_.range(7), n => ({
			name: moment().locale(locale).weekday(n).format('ddd')
		}));
	}

	/**
	 * Add the given number of months to the year and month state. Give a negative
	 * number for going backward.
	 *
	 * @param {Number} n - Number of months to add.
	 */
	addMonths(n) {
		const d = moment([this.state.year, this.state.month]).add(n, 'months');
		this.setState({ year: d.year(), month: d.month() });
	}

	/**
	 * Invoke the onPick function on props, with the given date.
	 *
	 * @param {Object} date - Moment.js instance.
	 */
	pickDate(date) {
		this.props.onPick(date);
	}

	/**
	 * Render the given weekday objects into <th>s.
	 *
	 * @param {Array<Object>} weekdays - Weekday objects.
	 * @return {Array<th>} <th> React components.
	 */
	renderWeekdays(weekdays) {
		return _.map(weekdays, wd => <th className="title" key={wd.name}>{wd.name}</th>);
	}

	/**
	 * Render the given date objects into <td>s.
	 *
	 * @param {Array<Object>} dates - Date objects.
	 * @return {Array<td>} <td> React components.
	 */
	renderDates(dates) {
		return _.map(dates, _.bind((d) => {
			if (_.isEmpty(_.intersection(d.types, ['out-of-month', 'unselectable']))) {
				return (<td
					className={['date'].concat(d.types).join(' ')}
					key={d.date}
					onClick={_.partial(this.pickDate, [d.year, d.month, d.date]).bind(this)}
				>{d.date}</td>);
			}
			const content = !_.contains(d.types, 'out-of-month') ? d.date : null;
			return <td className={['date'].concat(d.types).join(' ')} key={d.date}>{content}</td>;
		}, this));
	}

	/**
	 * Render the given week objects into <tr>s.
	 *
	 * @param {Array<Object>} weeks - Week objects.
	 * @return {Array<tr>} <tr> React components.
	 */
	renderWeeks(weeks) {
		return _.map(weeks, _.bind(w => (
			<tr className="week" key={w.number}>
				<td className="number" key="number">{w.number}</td>
				{this.renderDates(w.dates)}
			</tr>
		), this));
	}

	/**
	 * Transfer new year and month props to state.
	 *
	 * @param {Object} props - Props.
	 */
	componentWillReceiveProps(props) {
		this.setState({
			year: _.isFinite(props.initialYear) ? props.initialYear : this.state.year,
			month: _.isFinite(props.initialMonth) ? props.initialMonth : this.state.month
		});
	}

	/**
	 * Render complete DatePicker.
	 *
	 * @return {div} Datepicker as <div> React component.
	 */
	render() {
		const month = moment([this.state.year, this.state.month]).locale(this.props.locale);
		return (
			<div className="datepicker visible" onMouseDown={(e) => { e.preventDefault(); }}>
				<div className="datepicker-header">
					<div className="title">{month.format('MMMM')} {month.format('YYYY')}</div>
					<div
						className="previous"
						onMouseDown={this.addMonths.bind(this, -1)}
					> <i className="fa fa-caret-left" /> </div>
					<div
						className="next"
						onMouseDown={this.addMonths.bind(this, 1)}
					> <i className="fa fa-caret-right" /> </div>
				</div>
				<table className="month">
					<thead className="titles">
						<tr>
							<th className="title">{gettext('v')}</th>
							{this.renderWeekdays(this.getWeekdays(this.props.locale))}
						</tr>
					</thead>
					<tbody className="weeks">
						{this.renderWeeks(
							this.getWeeksMemo(this.props.locale, this.state.year, this.state.month))
						}
					</tbody>
				</table>
			</div>
		);
	}

}

Datepicker.defaultProps = {
	alterDateTypes(types) { return types; },
	locale: 'sv',
	onPick: () => null
};

Datepicker.propTypes = {
	alterDateTypes: PropTypes.func,
	initialYear: PropTypes.number.isRequired,
	initialMonth: PropTypes.number.isRequired,
	onPick: PropTypes.func,
	locale: PropTypes.string
};

export default Datepicker;
