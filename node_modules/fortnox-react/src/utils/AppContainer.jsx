import React from 'react';
import PropTypes from 'prop-types';
import devdebug from './DevDebug';

/**
 * The application Container
 *
 * @class
 * @name AppContainer
 *
 * @return {AppContainer}
 */
class AppContainer extends React.Component {
	constructor(props) {
		super(props);
		this.ctxLocationHasChanged = this.locationHasChanged.bind(this);
		this.ctxOnUserClickFrameContext = this.onUserClickFrameContext.bind(this);
		this.ctxOnNavigate = this.onNavigate.bind(this);
	}

	componentDidMount() {
		this.context.router.history.listen(this.ctxLocationHasChanged);
		document.addEventListener('click', this.ctxOnUserClickFrameContext, false);
		window.addEventListener('message', this.ctxOnNavigate);
		this.locationHasChanged(this.context.router.route.location);
	}

	componentWillUnmount() {
		document.removeEventListener('click', this.ctxOnUserClickFrameContext, false);
		window.removeEventListener('message', this.ctxOnNavigate);
	}

	static publish(payload) {
		if (!AppContainer.isFramedContext()) { return; }
		if (!payload.hasOwnProperty('type')) { devdebug('[AppContainer] publish: No event type defined on payload. Property "type" missing'); }
		window.parent.postMessage(payload, '*');
	}

	static isFramedContext() {
		return window.self !== window.top;
	}

	static isVesselEvent(event) {
		return event.data.hasOwnProperty('type');
	}

	static listenTo(type, fnCallback) {
		window.addEventListener('message', (event) => {
			const hasType = event.data.hasOwnProperty('type');

			if (!hasType || event.data.type !== type) {
				return null;
			}
			return fnCallback(event.data);
		});
	}

	onNavigate(event) {
		if (event.data.type === 'navigate-from-vessel-v1') {
			this.context.router.history.push(event.data.path);
		}
	}

	locationHasChanged(location) {
		if (!AppContainer.isFramedContext()) { return; }
		this.updateFramedContextHistory(this.getCurrentPath(location));
	}

	getCurrentPath(location) {
		return [this.props.namespace, location.pathname].join('');
	}

	onUserClickFrameContext() {
		AppContainer.publish({ type: 'child-click-v1' });
	}

	updateFramedContextHistory(fullPath) {
		AppContainer.publish({
			type: 'route-change-v1',
			route: fullPath
		});
	}

	/**
	 * @private
	 * @memberOf AppContainer
	 *
	 * @description
	 * Render the application contents
	 *
	 * @return {Object}
	 */
	render() {
		return this.props.children;
	}
}

AppContainer.contextTypes = {
	router: PropTypes.shape({
		history: PropTypes.object.isRequired
	})
};

AppContainer.propTypes = {
	namespace: PropTypes.string.isRequired,
	children: PropTypes.node.isRequired
};

export default AppContainer;
