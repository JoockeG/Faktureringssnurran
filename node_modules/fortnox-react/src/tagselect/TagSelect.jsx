import React from 'react';
import PropTypes from 'prop-types';
import { t as gettext } from 'c-3po';
import Backbone from '../utils/BackboneAdapter';
import _ from '../utils/UnderscoreAdapter';
import TagItem from './TagItem';
import HiddenTags from './HiddenTags';
import TagSelectAutoComplete from './AutoComplete';
import TagContainer from './Container';
import customPropTypes from '../utils/PropValidation';

class TagSelect extends React.Component {

	constructor(props) {
		super(props);
		this.state = {
			tags: [],
			tagWidths: [],
			value: '',
			offsetWidth: 0
		};

		this.acModel = new Backbone.Model();
		this.initModelProperty();
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Save a render by setting initial tags from the model,
	 * if there are any. Will default to an empty array.
	 *
	 * @returns {undefined}
	 */
	componentWillMount() {
		this.setTagsFromModel();
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Listen for changes on the AutoComplete model, whenever
	 * this change, we need to update the tags. Also listen to changes
	 * in the target model, if this model changes from elsewhere we
	 * also need to update the tags.
	 *
	 * @returns {undefined}
	 */
	componentDidMount() {
		this.acModel.on('change', this.onUserAddTag, this);
		this.props.model.on(`change:${this.props.modelProp}`, this.setTagsFromModel, this);
	}

	componentDidUpdate(prevProps, prevState) {
		this.props.model.set(this.props.modelProp, this.state.tags);
	}
	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Only render on state/prop changes
	 *
	 * @param {Object} nextProps
	 * @param {Object} nextState
	 *
	 * @returns {Boolean}
	 */
	shouldComponentUpdate(nextProps, nextState) {
		return (this.state !== nextState) || (this.props !== nextProps);
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Clean up eventlisteners.
	 *
	 * @returns {undefined}
	 */
	componentWillUnmount() {
		this.acModel.off('change', this.onUserAddTag, this);
		this.props.model.off(`change:${this.props.modelProp}`, this.setTagsFromModel, this);
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Setup the property on the model if it doesn't exist,
	 * there needs to be an array there by default so that we
	 * can add tags to it later.
	 *
	 * @returns {undefined}
	 */
	initModelProperty() {
		if (this.props.model.has(this.props.modelProp)) { return; }
		this.props.model.set(this.props.modelProp, []);
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Get tags from the model and update state
	 *
	 * @returns {undefined}
	 */
	setTagsFromModel() {
		this.setState({
			tags: this.props.model.get(this.props.modelProp)
		});
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Check if a tag (based on tag value) already exists in the tag list
	 *
	 * @param {String} tagValue
	 *
	 * @returns {Boolean}
	 */
	hasTag(tagValue) {
		return this.state.tags.filter(tag => tag.uniqueBy === tagValue).length > 0;
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Get the last selected tag (display value) from the AutoComplete model
	 *
	 * @returns {String}
	 */
	getCurrentTagFromAutocomplete() {
		// If provided use uniqueFn otherwise fallback to displayFn
		const uniqueByFn = this.props.uniqueFn || this.props.displayFn;
		return uniqueByFn(this.acModel);
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * When a user adds a tag via selection in the AutoComplete, put it in
	 * state and then render tags again. Sync tags to the model.
	 *
	 * @returns {undefined}
	 */
	onUserAddTag() {
		const { uniqueFn, displayFn, tagSetFn, model, modelProp } = this.props;

		if (this.hasTag(this.getCurrentTagFromAutocomplete())) { return; }

		const uniqueByFn = uniqueFn || displayFn;
		const tags = this.state.tags.concat([{
			tagTitle: displayFn(this.acModel),
			data: tagSetFn(this.acModel),
			uniqueBy: uniqueByFn(this.acModel)
		}]);

		this.setState({ tags });
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * When pressing the X icon on a tag or by using backspace remove it from the list,
	 * and then focus the input box again. Sync data to model.
	 *
	 * @param {number} index
	 *
	 * @returns {undefined}
	 */
	onUserRemoveTag(index) {
		const tags = this.state.tags.filter((item, i) => index !== i);

		const tagWidths = this.state.tagWidths.filter((width, i) => index !== i);

		this.setState({ tags, tagWidths });

		this.container.querySelector('input').focus();
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Determine if there are any Hidden tags
	 *
	 * @returns {Boolean}
	 */
	hasHiddenTags() {
		return this.getVisibleTags().length < this.state.tags.length;
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Child needs to report offsetWidth and trigger a render, since we dont actually know
	 * of the offsetWidth of the Container, until its rendered.
	 *
	 * @param {number} offsetWidth
	 *
	 * @returns {undefined}
	 */
	setOffsetWidth(offsetWidth) {
		this.setState({ offsetWidth });
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * The prop width can be either a string or a number. In all cases when it is a string
	 * it should be based on percent ie 100%. This means the Container can grow dynamically
	 * so we need to calculate the width by using the Container offsetWidth instead of a width
	 * supplied in props.
	 *
	 * @return {number}
	 */
	getContainerWidth() {
		return _.isNumber(this.props.width) ? this.props.width : this.state.offsetWidth;
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Get the available width, where we can render more tags, always making sure there
	 * is enough space to render the text indicating wether we have Hidden tags or not.
	 *
	 * @return {number}
	 */
	getAvailableTagWidth() {
		return this.getContainerWidth() - this.props.reservedWidth;
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Get a list of the tags that should be visible, based on how
	 * much available width there is in the Container vs the width of the tags.
	 *
	 * @return {Array}
	 */
	getVisibleTags() {
		let sumTagWidth = 0;
		return this.state.tags.filter((tag, index) => {
			sumTagWidth += (this.state.tagWidths[index] || 0) + this.props.tagMargin;
			return sumTagWidth < this.getAvailableTagWidth();
		});
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Set the tag width of a specific tag. This is used to figure out how
	 * many tags will fit when we traverse them and return tags to render.
	 *
	 * @param {number} index
	 * @param {number} width
	 *
	 * @returns {undefined}
	 */
	setTagWidth(index, width) {
		const state = this.state;
		state.tagWidths[index] = width;
		this.setState({ state });
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Get the current tags
	 *
	 * @return {Array}
	 */
	renderTags() {
		return this.getVisibleTags().map((tag, index) => (
			<TagItem
				key={`tag-${index}`}
				maxWidth={this.props.maxTagWidth}
				onUserRemoveTag={this.onUserRemoveTag.bind(this)}
				tagIndex={index}
				setTagWidth={this.setTagWidth.bind(this)}
				item={tag.tagTitle}
				disabled={this.props.disabled}
			/>)
		);
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Returns the number of Hidden tags
	 *
	 * @return {Object}
	 */
	getNumberOfHiddenTags() {
		return this.state.tags.length - this.getVisibleTags().length;
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Returns a string of css classes
	 *
	 * @return {String}
	 */
	getContainerCSSClasses() {
		return [
			'tagselect-container',
			this.state.hasFocus ? 'tagselect-container-focus' : '',
			this.props.disabled ? 'tagselect-container-disabled' : ''
		].join(' ');
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Remove tags when pressing backspace
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @returns {undefined}
	 */
	handleBackspace(e) {
		if (e.key !== 'Backspace' || this.hasSearchString()) { return; }
		const index = this.getVisibleTags().length - 1;
		this.onUserRemoveTag(index);
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * When the autocomplete input changes, set that value on
	 * state so we can figure out if there is text to remove when
	 * using backspace.
	 *
	 * @param {String} value
	 *
	 * @returns {undefined}
	 */
	handleChange(value) {
		this.setState({ value });
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Determine whether any search string currently exists within the input
	 *
	 * @return {Boolean}
	 */
	hasSearchString() {
		return this.state.value.length > 0;
	}

	/**
	 * @memberOf TagSelect
	 * @private
	 *
	 * @description
	 * Render the tagselector
	 *
	 * @returns {Object} React Elements
	 */
	render() {
		return (
			<div className="field-container" ref={(el) => { this.container = el; }}>
				<label>{this.props.title}</label>
				<TagContainer
					className={this.getContainerCSSClasses()}
					width={this.props.width}
					setOffsetWidth={this.setOffsetWidth.bind(this)}
					onKeyDown={this.handleBackspace.bind(this)}
				>
					<div className="tag-items-container">
						{this.renderTags()}
						<HiddenTags
							maxPopoverHeight={this.props.maxPopoverHeight}
							tags={this.state.tags}
							isVisible={this.hasHiddenTags()}
							linkText={this.props.hasMoreTagsText(this.getNumberOfHiddenTags())}
							onUserRemoveTag={this.onUserRemoveTag.bind(this)}
							disabled={this.props.disabled}
						/>
					</div>
					<TagSelectAutoComplete
						maxResults={this.props.maxResults}
						onChange={this.handleChange.bind(this)}
						onUserBlur={() => this.setState({ hasFocus: false })}
						onUserFocus={() => this.setState({ hasFocus: true })}
						displayFn={() => null}
						setFn={model => model.toJSON()}
						model={this.acModel}
						modelProp="id"
						collection={this.props.collection}
						disabled={this.props.disabled}
						placeholder={this.props.placeholder}
						getQuery={this.props.getQuery}
					>
						{this.props.children}
					</TagSelectAutoComplete>
				</TagContainer>
			</div>
		);
	}

}

TagSelect.defaultProps = {
	title: '',
	maxTagWidth: 100,
	tagMargin: 3,
	width: 500,
	reservedWidth: 80,
	disabled: false,
	placeholder: null,
	maxPopoverHeight: 300,
	maxResults: 10,
	uniqueFn: null,
	hasMoreTagsText(numHidden) {
		return [
			gettext`och`,
			numHidden,
			gettext`till`
		].join(' ');
	}
};

TagSelect.propTypes = {
	children: PropTypes.node.isRequired,
	collection: customPropTypes.collection.isRequired,
	maxTagWidth: PropTypes.number,
	width: PropTypes.oneOfType([
		PropTypes.string,
		PropTypes.number
	]),
	reservedWidth: PropTypes.number,
	hasMoreTagsText: PropTypes.func,
	title: PropTypes.string,
	tagSetFn: PropTypes.func.isRequired,
	tagMargin: PropTypes.number,
	model: customPropTypes.model.isRequired,
	modelProp: PropTypes.string.isRequired,
	displayFn: PropTypes.func.isRequired,
	uniqueFn: PropTypes.func,
	maxResults: PropTypes.number,
	maxPopoverHeight: PropTypes.number,
	disabled: PropTypes.bool,
	placeholder: PropTypes.string,
	getQuery: PropTypes.func
};

export default TagSelect;
