import React from 'react';
import PropTypes from 'prop-types';
import AutocompleteTable from '../autocomplete/Table';
import AutocompleteInput from '../autocomplete/Input';
import _ from '../utils/UnderscoreAdapter';
import customPropTypes from '../utils/PropValidation';
import MeasureWidth from '../utils/MeasureWidth';

// Make a request every 200ms (while changes occur in the ac field)
const searchInterval = 200;

class TagSelectAutocomplete extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			searchPhrase: '',
			activeRowIndex: -1,
			isVisible: false,
			tableMinWidth: 0,
			isFocused: false
		};

		this.ctxHide = this.hide.bind(this);
		this.debouncedSearch = _.debounce((searchPhrase) => {
			this.search(searchPhrase);
		}, searchInterval);
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Setup events and place the offset width in state
	 * so that we may use it to determine minimum width of dropdown Table of AC-results.
	 *
	 * @returns {undefined}
	 */
	componentDidMount() {
		document.addEventListener('mouseup', this.ctxHide);
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Teardown of events
	 *
	 * @returns {undefined}
	 */
	componentWillUnmount() {
		document.removeEventListener('mouseup', this.ctxHide);
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Determine if we should make a selection, if no models
	 * exists in the collection dont do anything.
	 *
	 * @return {Boolean}
	 */
	shouldSelect() {
		return this.props.collection.length > 0;
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Set the selected Row
	 *
	 * @param {Number} index
	 *
	 * @returns {undefined}
	 */
	setSelected(index) {
		if (!this.shouldSelect()) { return; }
		this.props.model.set(this.props.setFn(this.props.collection.at(index))).trigger('change');
		this.setState({
			isVisible: false,
			hasSelected: true,
			searchPhrase: ''
		});
		this.acInput.focus();
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Determine if the event originated from within the AutoComplete Container
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @return {Boolean}
	 */
	isWithinAC(e) {
		return this.container.contains(e.target);
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Whenever we hide the AutoComplete, make sure we're not clicking
	 * somewhere inside of it. Unless we are clicking on a "tr" tag. Reset
	 * the activeRowIndex to 0
	 *
	   * @param {SyntheticEvent} e
	 *
	 * @returns {undefined}
	 */
	hide(e, isForcefullyHidden = false) {
		if (this.isWithinAC(e) && !isForcefullyHidden) { return; }
		this.setState({
			isVisible: false,
			activeRowIndex: -1
		});
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Whenever the Content in the input changes, update state and perform a search
	 *
	 * @param {String} value
	 *
	 * @returns {undefined}
	 */
	onUserChange(value) {
		const searchPhrase = value || '';
		this.setState({ searchPhrase });
		this.debouncedSearch(searchPhrase);
		this.props.onChange(searchPhrase);
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Perform a search (hits the backend)
	 *
	 * @param {String} searchPhrase
	 *
	 * @return {Promise}
	 */
	search(searchPhrase) {
		const query = this.props.getQuery(searchPhrase);
		return this.props.collection.fetch(query)
			.then(() => {
				this.setState({
					isVisible: true,
					activeRowIndex: 0
				});
			});
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Set the index of the Row that is currently active, used for when making
	 * the actual selection (Click/Tab/Enter)
	 *
	 * @param {number} index
	 *
	 * @returns {undefined}
	 */
	setActiveRowIndex(index) {
		this.setState({
			activeRowIndex: index
		});
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Render the AutoComplete
	 *
	 *
	 * @returns {Object} React Elements
	 */
	render() {
		return (
			<MeasureWidth
				className="field-container autocomplete"
				onWidth={(width) => { this.setState({ tableMinWidth: width }); }}
			>
				<div ref={(el) => { this.container = el; }} className={`field-container autocomplete ${this.props.disabled ? 'autocomplete-disabled ' : ''}${this.props.className}`}>
					<label>{this.props.title}</label>
					<AutocompleteInput
						ref={(el) => { this.acInput = el; }}
						disabled={this.props.disabled}
						value={this.state.searchPhrase}
						tooltip={this.props.tooltip}
						tooltipAlign={this.props.tooltipAlign}
						activeRowIndex={this.state.activeRowIndex}
						isVisible={this.state.isVisible}
						collection={this.props.collection}
						maxResults={this.props.maxResults}
						onUserBlur={this.props.onUserBlur}
						onUserFocus={this.props.onUserFocus}
						onUserHide={(e, isForcefullyHidden) => this.hide(e, isForcefullyHidden)}
						onUserSetRowIndex={this.setActiveRowIndex.bind(this)}
						onUserSelect={this.setSelected.bind(this)}
						onUserChange={this.onUserChange.bind(this)}
						onUserDropDown={this.search.bind(this)}
						placeholder={this.props.placeholder}
					/>
					<AutocompleteTable
						minWidth={this.state.tableMinWidth}
						activeRowIndex={this.state.activeRowIndex}
						isVisible={this.state.isVisible}
						searchPhrase={this.state.searchPhrase}
						collection={this.props.collection}
						maxResults={this.props.maxResults}
						onMouseOverRow={this.setActiveRowIndex.bind(this)}
						onUserSelect={this.setSelected.bind(this)}
					>
						{this.props.children}
					</AutocompleteTable>
				</div>
			</MeasureWidth>
		);
	}
}


TagSelectAutocomplete.defaultProps = {
	setFn() {
		return 'define setFn';
	},
	className: '',
	maxResults: 10,
	title: null,
	disabled: false,
	tooltip: null,
	tooltipAlign: null,
	onUserBlur() { return null; },
	onUserFocus() { return null; },
	onChange() { return null; },
	placeholder: null,
	getQuery(searchPhrase) {
		return {
			data: {
				q: searchPhrase
			}
		};
	}
};

TagSelectAutocomplete.propTypes = {
	setFn: PropTypes.func,
	children: PropTypes.node.isRequired,
	collection: PropTypes.any.isRequired,
	className: PropTypes.string,
	title: PropTypes.string,
	disabled: PropTypes.bool,
	tooltip: PropTypes.string,
	tooltipAlign: PropTypes.string,
	onUserBlur: PropTypes.func,
	onUserFocus: PropTypes.func,
	onChange: PropTypes.func,
	model: customPropTypes.model.isRequired,
	maxResults: PropTypes.number,
	placeholder: PropTypes.string,
	getQuery: PropTypes.func
};


export default TagSelectAutocomplete;
