import React from 'react';
import PropTypes from 'prop-types';
import customPropTypes from '../utils/PropValidation';

class Row extends React.Component {

	constructor(props) {
		super(props);
		this.inputNodes = null;
	}

	/**
	 * @memberOf Row
	 * @private
	 *
	 * @description
	 * Get a list of all the input nodes on this specific row
	 * corresponding to the <tr> the "this" context
	 *
	 * @returns {Array}
	 */
	getInputNodes() {
		if (this.inputNodes) { return this.inputNodes; }
		this.inputNodes = Array.prototype.slice.call(
			this.el.querySelectorAll('input')
		);
		return this.getInputNodes();
	}

	/**
	 * @memberOf Row
	 * @private
	 *
	 * @description
	 * Get the first input node of the next <tr> row ie
	 * the sibling of the current <tr> corresponding to
	 * the "this" context
	 *
	 * @returns {Node|null}
	 */
	getNextRowInputNode() {
		const node = this.el.nextSibling;
		if (!node) { return null; }
		return node.querySelector('input');
	}

	/**
	 * @memberOf Row
	 * @private
	 *
	 * @description
	 * Get the index of the node
	 * (Within the list of input nodes of the row)
	 *
	 * @param {Node} node
	 *
	 * @returns {number}
	 */
	getInputIndex(node) {
		return this.getInputNodes().indexOf(node);
	}

	/**
	 * @memberOf Row
	 * @private
	 *
	 * @description
	 * Determines if this the last input node of the current row <tr>
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @returns {Boolean}
	 */
	isLastRowInput(e) {
		return (this.getInputIndex(e.target) + 1 >= this.getInputNodes().length);
	}

	/**
	 * @memberOf Row
	 * @private
	 *
	 * @description
	 * Focus the next input wether this is on the current <tr> row or
	 * the next sibling <tr> is not relevant, as long as it exists.
	 *
	 * @param {SyntheticEvent} e
	 * @param {Node} nextInput Reference to the next input node on this <tr> row.
	 * @param {Node} nextRowInput Reference to the input node of the next <tr> sibling row.
	 *
	 * @return {Node|null}
	 */
	focusNextInput(e, nextInput, nextRowInput) {
		if (this.isLastRowInput(e) && nextRowInput) {
			return nextRowInput.focus();
		}
		return nextInput.focus();
	}

	/**
	 * @memberOf Row
	 * @private
	 *
	 * @description
	 * If the keyup event was from a Enter or Tab keys, determine if we
	 * should focus next available inputs or take any other actions.
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @returns {undefined}
	 */
	handleKeyUp(e) {
		if (e.key !== 'Enter' && e.key !== 'Tab') { return; }
		const index = this.getInputIndex(e.target);
		const nextInput = this.getInputNodes()[index + 1];
		const nextRowInput = this.getNextRowInputNode(e);

		// Call onEnter or onTab in props.
		this.props[this.props.keyMap[e.key]].apply(this, [e, nextInput, nextRowInput, index]);
	}

	/**
	 * @memberOf Row
	 * @private
	 *
	 * @description
	 * Execute the onClick callback supplied in props
	 * when the row is clicked.
	 *
	 * @returns {undefined}
	 */
	handleClick() {
		this.props.onClick(this.props.model);
	}

	/**
	* @memberOf Row
	* @private
	*
	* @description
	* Render the row
	*
	* @return {Object}
	*
	*/
	render() {
		return (
			<tr
				ref={(el) => { this.el = el; }}
				className={this.props.className}
				onClick={this.handleClick.bind(this)}
				onKeyUp={this.handleKeyUp.bind(this)}
			>
				{this.props.children}
			</tr>
		);
	}

}


Row.defaultProps = {

	keyMap: {
		Enter: 'onEnter',
		Tab: 'onTab'
	},

	className: '',

	onTab(e) { return e; },

	onEnter(e, nextInput, nextRowInput /* currentIndex */) {
		if (!nextInput && !nextRowInput) { return; }
		this.focusNextInput(e, nextInput, nextRowInput);
	},

	onClick() { return null; }

};

Row.propTypes = {
	keyMap: PropTypes.object,
	onClick: PropTypes.func,
	model: customPropTypes.model.isRequired,
	className: PropTypes.string,
	children: PropTypes.node.isRequired
};

export default Row;
