
import 'whatwg-fetch';
import Backbone from '../utils/BackboneAdapter';
import headerParser from '../ajax/HeaderParser';
import responseParser from '../ajax/ResponseParser';
import defaultBus from '../utils/EventBus';
import devdebug from '../utils/DevDebug';
import unauthorizedHandler from '../utils/UnauthorizedHandler';
import { getFid } from '../utils/Fid';


const options = {
	responseEventMap: [],
	requestToken: getFid() || window.sessionStorage.fid
};

let events;


function getErrorTrigger() {
	if (process.env.NODE_ENV !== 'production') {
		return 'error:debug';
	}
	return 'error:unknown';
}

/**
 *
 * @description
 * Check the http status, if all good return response,
 * otherwise throw exception which can be caught using .catch()
 * in promise chain.
 *
 * @param {Object} response
 * @return {Object}
 *
 */
function handleErrors(response) {
	const isValidResponse = (response.status >= 200 && response.status < 300);
	const hasContent = response.status !== 204;
	const isNotAuthorized = (response.status === 401);

	const responseHandler = data => new Promise((resolve) => {
		resolve({
			data: responseParser(data),
			headers: headerParser(response.headers)
		});
	});

	const jsonHandler = () => response.json().then(data => responseHandler(data))
		.catch(() => {
			throw new Error(`ERROR.PARSING.JSON:${response.url}`);
		});

	if (isNotAuthorized) {
		unauthorizedHandler();
	}

	if (!isValidResponse && hasContent) {
		events.trigger(getErrorTrigger(), response.statusText);
		devdebug(`HTTP.CODE.${response.status}`);
		return jsonHandler().then((res) => { throw res.data; });
	}

	return hasContent ? jsonHandler() : responseHandler({});
}

/**
 *
 * @description
 * Determine if request should have a Body
 *
 * @param {String} type
 * @return {Boolean}
 *
 */
function shouldHaveBody(type) {
	return ['POST', 'PUT', 'DELETE', 'PATCH'].indexOf(type) !== -1;
}


/**
 *
 * @description
 * Build a string like: url?param=1&b=2&c=3
 * Used in get requests
 *
 * @param {String} type
 * @param {Object} params
 *
 * @return {String}
 */
function getParams(type, params = {}) {
	if (type !== 'GET') { return ''; }
	return Object.keys(params).map((key, i) => {
		const prefix = (i === 0 ? '?' : '&');
		return [prefix, key, '=', params[key]].join('');
	}).join('');
}

/**
 *
 * @description
 * Generate configuration object for the request
 *
 * @param {Object} params
 *
 * @return {Object}
 */
function getConfig(params) {
	const config = {
		method: params.type,
		credentials: 'same-origin', // Always send cookies
		headers: {
			'X-TOKEN': params.requestToken || options.requestToken,
			'X-METADATA': 'SKIP',
			'X-REQUESTED-WITH': 'fetch'
		}
	};
	if (shouldHaveBody(params.type)) {
		config.body = params.data;
	}
	return config;
}


/**
 * @memberOf Backbone
 * @description
 * Perform an Ajax request (Delegated from sync)
 *
 * @param {Object} params
 *
 * @return {Promise}
 */
Backbone.ajax = params => fetch(params.url + getParams(params.type, params.data), getConfig(params))
	.then(handleErrors)
	.then((response) => {
		params.success(response.data);
		return new Promise((resolve) => {
			resolve(response);
		});
	});


export default (eventBus) => {
	events = eventBus || defaultBus;
	return fetch;
};
