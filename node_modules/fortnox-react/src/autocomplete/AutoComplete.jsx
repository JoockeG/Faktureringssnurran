
import React from 'react';
import PropTypes from 'prop-types';
import { t as gettext } from 'c-3po';

import _ from '../utils/UnderscoreAdapter';
import customPropTypes from '../utils/PropValidation';
import AutoCompleteTable from './Table';
import AutoCompleteInput from './Input';

// Make a request every 200ms (while changes occur in the ac field)
const searchInterval = 200;
const REQUIRED_ERROR = [gettext`Detta fält får inte vara tomt`];

class AutoComplete extends React.Component {

	constructor(props) {
		super(props);
		this.state = {
			searchPhrase: null,
			activeRowIndex: -1,
			isVisible: false,
			isProcessing: false,
			hasSelected: false,
			tableMinWidth: 0,
			validationMessages: []
		};

		this.ctxHide = this.hide.bind(this);
		this.debouncedSearch = _.debounce((searchPhrase) => {
			this.search(searchPhrase);
		}, searchInterval);
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Save a render. Sync any value from the model to the input field just
	 * before we mount the component.
	 *
	 * @returns {undefined}
	 */
	componentWillMount() {
		this.handleModelChange();
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Setup events and place the offset width in state
	 * so that we may use it to determine minimum width of dropdown Table of AC-results.
	 *
	 * @returns {undefined}
	 */
	componentDidMount() {
		this.props.model.on(`change:${this.props.modelProp}`, this.handleModelChange, this);
		this.setupValidation();
		document.addEventListener('mouseup', this.ctxHide);
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Teardown of events
	 *
	 * @returns {undefined}
	 */
	componentWillUnmount() {
		this.props.model.off(`change:${this.props.modelProp}`, this.handleModelChange, this);
		this.props.model.off('validate:prop', this.triggerFieldValidation, this);
		document.removeEventListener('mouseup', this.ctxHide);
	}

	setupValidation() {
		if (this.props.required && !this.isValid()) {
			this.props.model.setInvalidProp(this.props.modelProp);
		}
		this.props.model.on('validate:prop', this.triggerFieldValidation, this);
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Determine if we should make a selection, if no models
	 * exists in the collection or if the selection is outside
	 * the visible range (maxResults) we dont select anything.
	 *
	 * @param {Number} index
	 *
	 * @return {Boolean}
	 */
	shouldSelect(index) {
		return (this.props.collection.length > 0 && index < this.props.maxResults);
	}

	/**
	 * @memberOf autocomplete
	 * @private
	 * Determine wether AutoComplete is in valid state or not.
	 * @return {Boolean}
	 */
	isValid() {
		return this.props.required && this.state.searchPhrase && this.state.searchPhrase.length > 0;
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 * Trigger the field validation when receiving the validate event on the model
	 * @return {void}
	 */
	triggerFieldValidation() {
		let validationMessages = REQUIRED_ERROR;
		if (!this.props.required) { return; }
		if (this.isValid()) {
			this.props.model.unsetInvalidProp(this.props.modelProp);
			validationMessages = [];
		} else {
			this.props.model.setInvalidProp(this.props.modelProp);
		}
		this.setState({ validationMessages });
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Set the selected Row, and mark the field valid.
	 *
	 * @param {number} index
	 *
	 * @returns {undefined}
	 */
	setSelected(index) {
		if (!this.shouldSelect(index)) { return; }
		this.props.model.set(this.props.setFn(this.props.collection.at(index)));
		this.props.model.unsetInvalidProp(this.props.modelProp);
		this.setState({
			isVisible: false,
			hasSelected: true,
			validationMessages: [],
			searchPhrase: this.props.displayFn(this.props.model)
		});
		// ReactDOM.findDOMNode(this).querySelector('input').focus();
		this.acInput.focus();
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Update the state when the model changes
	 *
	 * @returns {undefined}
	 */
	handleModelChange() {
		this.setState({
			searchPhrase: this.props.displayFn(this.props.model)
		});
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Determine if the event originated from within the AutoComplete Container
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @return {Boolean}
	 */
	isWithinAC(e) {
		return this.container.contains(e.target);
	}

	isRequired() {
		return this.shouldResetSearchPhrase() && this.props.required;
	}

	isSearchPhraseEmpty() {
		const { searchPhrase } = this.state;
		return !searchPhrase || searchPhrase.length === 0;
	}

	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * If the field is
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @return {Boolean}
	 */
	shouldResetSearchPhrase() {
		return this.state.isVisible && !this.state.hasSelected && this.isSearchPhraseEmpty();
	}

	shouldHide(e) {
		return (!this.state.isVisible || this.isWithinAC(e));
	}

	getValidationMessages() {
		if (this.props.validateOnBlur && this.isRequired()) {
			return REQUIRED_ERROR;
		}
		return this.state.validationMessages;
	}


	/**
	 * @memberOf AutoComplete
	 * @private
	 *
	 * @description
	 * Hides the AutoComplete as the result of clicking somewhere outside of it.
	 * Whenever we hide the AutoComplete, make sure we're not clicking
	 * somewhere inside of it. Unless we are clicking on a "tr" tag. Reset
	 * the activeRowIndex to 0.
	 *
	 * isForcefullyHidden can be set to true if we want to hide the AutoComplete
	 * regardless of its current state. This is used by the input child component.
	 *
	 * @param {Object} e - event object
	 * @param {Boolean} isForcefullyHidden - hide regardless of state
	 *
	 * @returns {undefined}
	 */
	hide(e, isForcefullyHidden) {
		if (this.shouldHide(e) && !isForcefullyHidden) { return; }

		const searchPhrase = this.shouldResetSearchPhrase() ? '' : this.getRevertedSearchPhrase();
		const validationMessages = this.getValidationMessages();

		this.setState({
			isVisible: false,
			activeRowIndex: -1,
			validationMessages,
			searchPhrase
		}, () => {
			if (!this.hasResetFn()) { return; }
			if (!this.shouldDeselectItem(searchPhrase)) { return; }
			this.props.resetFn(this.props.model);
		});
	}

	/**
	 * If the value entered is empty string, the user backspaced from a previous none-empty string.
	 * This is an indication that we should clear the field by running the resetFn method if it has
	 * been set as a prop.
	 * @return {Boolean}
	 */
	hasResetFn() {
		return this.props.hasOwnProperty('resetFn') && this.props.resetFn !== null;
	}

	/**
	 * If no new value is set, rather than clearing the field, we revert to the
	 * last searchPhrase that was set on the model, using the displayFn method.
	 *
	 * @returns	{String}
	 */
	getRevertedSearchPhrase() {
		return this.props.displayFn(this.props.model);
	}

	/**
	 * Determine wether we should indicate that the field has nothing selected
	 * at certain points, the way we know if whatever value previously set should be
	 * unset is if the value length is 0, this means the user made a "delete" / "backspace"
	 * operation on value of the field.
	 *
	 * @returns {Boolean}
	 */
	shouldDeselectItem(value) {
		return value.length === 0;
	}

	/**
	 * @memberOf Autocomplete
	 * @private
	 *
	 * @description
	 * Whenever the content in the input changes, update state and perform a search
	 *
	 * @param {String} value
	 *
	 * @returns {undefined}
	 */
	onUserChange(value) {
		const searchPhrase = value || '';
		this.setState({ searchPhrase });
		this.props.onChange(searchPhrase);
		if (this.hasResetFn() && this.shouldDeselectItem(value)) {
			this.setState({
				isVisible: false,
				hasSelected: false,
				activeRowIndex: -1
			});
			return this.props.resetFn.call(this, this.props.model);
		}
		return this.debouncedSearch(searchPhrase);
	}

	/**
	 * @memberOf Autocomplete
	 * @private
	 *
	 * @description
	 * Perform a search (hits the backend)
	 *
	 * @param {String} searchPhrase
	 *
	 * @returns {Promise}
	 */
	search(searchPhrase) {
		const query = this.props.getQuery(searchPhrase);
		this.setState({ isVisible: true, isProcessing: true });
		return this.props.collection.fetch(query)
			.then(() => {
				this.setState({
					isProcessing: false,
					activeRowIndex: 0
				});
			});
	}

	/**
	 * @memberOf Autocomplete
	 * @private
	 *
	 * @description
	 * Set the index of the row that is currently active, used for when making
	 * the actual selection (Click/Tab/Enter)
	 *
	 * @param {number} index
	 *
	 * @returns {undefined}
	 */
	setActiveRowIndex(index) {
		this.setState({
			activeRowIndex: index
		});
	}

	/**
	 * @memberOf Autocomplete
	 * @private
	 *
	 * @description
	 * Render the autocomplete
	 *
	 * @returns {Object} React Elements
	 */
	render() {
		return (
			<div ref={(container) => { this.container = container; }} className={`field-container autocomplete ${this.props.className}`}>
				<label>{this.props.title}</label>
				<AutoCompleteInput
					ref={(acInput) => { this.acInput = acInput; }}
					disabled={this.props.disabled}
					value={this.state.searchPhrase}
					validateOnBlur={this.props.validateOnBlur}
					tooltip={this.props.tooltip}
					tooltipAlign={this.props.tooltipAlign}
					activeRowIndex={this.state.activeRowIndex}
					isVisible={this.state.isVisible}
					placeholder={this.props.placeholder}
					collection={this.props.collection}
					maxResults={this.props.maxResults}
					onUserHide={(e, isForcefullyHidden) => this.hide(e, isForcefullyHidden)}
					onUserSetRowIndex={this.setActiveRowIndex.bind(this)}
					onUserSelect={this.setSelected.bind(this)}
					onUserChange={this.onUserChange.bind(this)}
					onFailedValidation={() => this.setState({ validationMessages: REQUIRED_ERROR })}
					required={this.props.required}
					messages={this.state.validationMessages}
					onUserDropDown={this.search.bind(this)}
				/>
				<AutoCompleteTable
					minWidth={this.container ? this.container.parentNode.offsetWidth : 60}
					activeRowIndex={this.state.activeRowIndex}
					isVisible={this.state.isVisible}
					isProcessing={this.state.isProcessing}
					searchPhrase={this.state.searchPhrase}
					collection={this.props.collection}
					maxResults={this.props.maxResults}
					onMouseOverRow={this.setActiveRowIndex.bind(this)}
					onUserSelect={this.setSelected.bind(this)}
				>
					{this.props.children}
				</AutoCompleteTable>
			</div>
		);
	}
}


AutoComplete.defaultProps = {

	setFn() {
		return 'define setFn';
	},

	displayFn() {
		return 'define displayFn';
	},

	onChange() {
		return null;
	},

	/**
	 * @memberOf Autocomplete
	 * @private
	 *
	 * @description
	 * Get query in format that ajax component understand. Used to later generate
	 * get parameters to fulfill the request.
	 *
	 * @param {String} searchPhrase
	 *
	 * @returns {Object} Parameters
	 */
	getQuery(searchPhrase) {
		return {
			data: {
				q: searchPhrase
			}
		};
	},

	className: '',
	maxResults: 10,
	required: false,
	title: null,
	disabled: false,
	tooltip: null,
	tooltipAlign: 'top',
	placeholder: null,
	resetFn: null,
	validateOnBlur: true
};

AutoComplete.propTypes = {
	setFn: PropTypes.func,
	displayFn: PropTypes.func,
	modelProp: PropTypes.string.isRequired,
	collection: customPropTypes.collection.isRequired,
	model: customPropTypes.model.isRequired,
	className: PropTypes.string,
	title: PropTypes.string,
	disabled: PropTypes.bool,
	tooltip: PropTypes.string,
	tooltipAlign: PropTypes.string,
	maxResults: PropTypes.number,
	getQuery: PropTypes.func,
	placeholder: PropTypes.string,
	required: PropTypes.bool,
	onChange: PropTypes.func,
	resetFn: PropTypes.func,
	validateOnBlur: PropTypes.bool,
	children: PropTypes.node.isRequired
};


export default AutoComplete;
