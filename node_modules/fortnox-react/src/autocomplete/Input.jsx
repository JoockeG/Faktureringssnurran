import React from 'react';
import PropTypes from 'prop-types';

class AutocompleteInput extends React.Component {
	constructor(props) {
		super(props);
		this.onEscape = this.onEscape.bind(this);
		this.handleDropDown = this.handleDropDown.bind(this);
		this.handleChange = this.handleChange.bind(this);
		this.handleBlur = this.handleBlur.bind(this);
		this.handleKeyDown = this.handleKeyDown.bind(this);
	}

	componentDidMount() {
		this.text.addEventListener('keydown', this.onEscape);
	}

	componentWillUnmount() {
		this.text.removeEventListener('keydown', this.onEscape);
	}
	/**
	 * @memberOf AutocompleteInput
	 * @private
	 *
	 * @description
	 * Determine if we should select the item. This list must be visible,
	 * and the key must be either Enter or Tab, otherwise no selection can
	 * be made.
	 *
	 * @param {Object} e event
	 *
	 * @return {Boolean}
	 */
	shouldSelect(e) {
		return ['Enter', 'Tab'].indexOf(e.key) >= 0 && this.props.isVisible;
	}

	/**
	 * @memberOf AutocompleteInput
	 * @private
	 *
	 * @description
	 * Determine if the user is navigating in the resultlist using arrow up/down
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @return {Boolean}
	 */
	isNavigatingList(e) {
		return ['ArrowDown', 'ArrowUp'].indexOf(e.key) >= 0;
	}

	/**
	 * @memberOf AutocompleteInput
	 * @private
	 *
	 * @description
	 * Determine if we are moving up or down,
	 * increasing or decreasing the active Row
	 *
	 * @param {String} key
	 *
	 * @return {number}
	 */
	getNewRowIndex(key) {
		const keys = {
			ArrowDown: (this.props.activeRowIndex + 1),
			ArrowUp: (this.props.activeRowIndex - 1)
		};
		if (keys.hasOwnProperty(key)) {
			return Math.min(
				Math.max(keys[key], 0),
				Math.min(this.props.collection.length, this.props.maxResults) - 1
			);
		}
		return this.props.activeRowIndex;
	}

	/**
	 * @memberOf AutocompleteInput
	 * @private
	 *
	 * @description
	 * If the user presses arrowdown we should do an
	 * empty search to simply show a list of items, unless
	 * a list is already visible, then simply navigate between
	 * items in that list.
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @returns {undefined}
	 */
	handleArrowDown(e) {
		if (e.key !== 'ArrowDown' || this.props.isVisible) { return; }
		this.handleDropDown(this.text.value);
	}

	/**
	 * @memberOf AutocompleteInput
	 * @private
	 *
	 * @description
	 * This is used to prevent the caret from moving to the
	 * beginning of the input field when there is already
	 * a text in it, when using arrowup.
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @returns {undefined}
	 */
	shouldStopCaretRepositioning(e) {
		if (e.key !== 'ArrowUp') { return; }
		e.preventDefault();
	}

	/**
	 * @memberOf AutocompleteInput
	 * @private
	 *
	 * @description
	 * On each keydown event we determine
	 * if we should change the active Row and
	 * if any search should be performed.
	 *
	 * @param {SyntheticEvent} e
	 *
	 * @returns {undefined}
	 */
	handleKeyDown(e) {
		const activeRowIndex = this.getNewRowIndex(e.key);
		if (this.shouldSelect(e)) {
			this.props.onUserSelect(this.props.activeRowIndex);
		}

		if (this.isNavigatingList(e)) {
			this.props.onUserSetRowIndex(activeRowIndex);
			this.handleArrowDown(e);
			this.shouldStopCaretRepositioning(e);
		}
	}

	/**
	 * Hide dropdown on Escape and prevent propagation when autocomplete is visible
	 *
	 * @param  {[type]} event KeyDown event
	 * @return {undefined}
	 */
	onEscape(event) {
		const { key } = event;

		if (key === 'Escape' || key === 'Esc') {
			if (this.props.isVisible) {
				event.stopPropagation();
				this.props.onUserHide(event, true);
			}
		}
	}

	/**
	 * @memberOf AutocompleteInput
	 * @private
	 *
	 * @description
	 * When the Content of the input field changes, update
	 * state in parent via props method onUserChange() - executes in
	 * parent context.
	 *
	 * @returns {undefined}
	 */
	handleChange() {
		this.props.onUserChange(this.text.value);
	}

	/**
   * @memberOf AutocompleteInput
   * @private
   *
   * @description
   * Determine if we're in a valid state.
   *
   * @returns {Boolean}
   */
	isValid() {
		return (!this.props.isVisible && this.props.value.length < 1 && this.props.required);
	}

	/**
	 * @memberOf AutocompleteInput
	 * @private
	 *
	 * @description
	 * Perform empty search which triggers and renders the dropdown AC-Table
	 *
	 * @returns {undefined}
	 */
	handleDropDown(e) {
		const node = this.text;

		if (this.props.isVisible) {
			return this.props.onUserHide(e, true);
		}
		this.props.onUserDropDown('');
		this.focus();
		return node.setSelectionRange(0, node.value.length);
	}

	/**
   * @memberOf AutocompleteInput
   * @private
   *
   * @description
   * When bluring the field run validation and call the failed method in the parent
   * context if validation didn't pass.
   *
   * @returns {undefined}
   */
	handleBlur() {
		if (this.isValid() && this.props.validateOnBlur) {
			this.props.onFailedValidation();
		}
		this.props.onUserBlur();
	}

	/**
	 * @private
	 * @memberOf AutocompleteInput
	 *
	 * @description
	 *
	 * Determine we have any validation messages
	 *
	 * @return {Boolean}
	 *
	 */
	hasValidationMessages() {
		return this.props.messages.length > 0;
	}

	/**
	 * @private
	 * @memberOf AutocompleteInput
	 *
	 * @description
	 *
	 * Classes of validations and tooltips
	 *
	 * @return {String}
	 *
	 */
	getTooltipClasses() {
		return [
			'autocomplete-input-container',
			this.hasTooltip() ? `hint ${this.getTooltipAlign()}` : '',
			this.hasValidationMessages() ? 'hint--always hint--error' : ''
		].join(' ');
	}

	/**
	 * @private
	 * @memberOf AutocompleteInput
	 *
	 * @description
	 *
	 * String of the tooltip or validation messages
	 * Validation should triumph tooltip
	 *
	 * @return {String}
	 *
	 */
	getTooltip() {
		if (this.hasValidationMessages()) {
			return this.props.messages[0];
		}
		return this.props.tooltip;
	}

	/**
	 * @private
	 * @memberOf AutocompleteInput
	 *
	 * @description
	 *
	 * Determine if a tooltip was declared
	 *
	 * @return {Boolean}
	 *
	 */
	hasTooltip() {
		return this.hasValidationMessages() || this.props.tooltip !== null;
	}

	/**
	 * @private
	 * @memberOf AutocompleteInput
	 *
	 * @description
	 *
	 * Get the tooltip align, default: top.
	 *
	 * @return {String}
	 *
	 */
	getTooltipAlign() {
		return `hint--${this.props.tooltipAlign}`;
	}

	focus() {
		this.text.focus();
	}

	/**
	 * @memberOf AutocompleteInput
	 * @private
	 *
	 * @description
	 * Render the input field and the arrow icon
	 *
	 * @return {Object}
	 */
	render() {
		return (
			<div className={this.getTooltipClasses()} data-hint={this.getTooltip()}>
				<input
					ref={(el) => { this.text = el; }}
					type="text"
					className="textfield"
					disabled={this.props.disabled}
					placeholder={this.props.placeholder}
					onChange={this.handleChange}
					value={this.props.value}
					onBlur={this.handleBlur}
					onFocus={this.props.onUserFocus}
					onKeyDown={this.handleKeyDown}
				/>
				<i
					onClick={!this.props.disabled ? this.handleDropDown : null}
					className="fa fa-chevron-down"
				/>
			</div>
		);
	}
}

AutocompleteInput.defaultProps = {
	onUserFocus: () => null,
	onUserBlur: () => null,
	value: '',
	messages: [],
	tooltipAlign: 'top',
	required: false,
	isVisible: false,
	disabled: false,
	placeholder: null,
	tooltip: null,
	validateOnBlur: true,
	onFailedValidation() { return null; },
	onUserHide() { return null; }
};

AutocompleteInput.propTypes = {
	tooltipAlign: PropTypes.string,
	required: PropTypes.bool,
	isVisible: PropTypes.bool,
	activeRowIndex: PropTypes.number.isRequired,
	onUserSelect: PropTypes.func.isRequired,
	onUserSetRowIndex: PropTypes.func.isRequired,
	onUserChange: PropTypes.func.isRequired,
	onUserDropDown: PropTypes.func.isRequired,
	disabled: PropTypes.bool,
	value: PropTypes.string,
	onUserBlur: PropTypes.func,
	onUserFocus: PropTypes.func,
	placeholder: PropTypes.string,
	onFailedValidation: PropTypes.func,
	collection: PropTypes.any.isRequired,
	maxResults: PropTypes.number.isRequired,
	onUserHide: PropTypes.func,
	messages: PropTypes.array,
	validateOnBlur: PropTypes.bool,
	tooltip: PropTypes.oneOfType([
		PropTypes.string
	])
};

export default AutocompleteInput;
