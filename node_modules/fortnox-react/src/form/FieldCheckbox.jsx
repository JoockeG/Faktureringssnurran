import React from 'react';
import customPropTypes from '../utils/PropValidation';
import PropTypes from 'prop-types';
import _ from '../utils/UnderscoreAdapter';
import { t as gettext } from 'c-3po';

const getFieldValue = value => (value !== null ? value : false);

class FieldCheckBox extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			value: getFieldValue(this.props.model.get(this.props.modelProp)),
			messages: [],
			isValid: true
		};
	}

	/**
	 * Setup events
	 * @return {undefined}
	 */
	componentDidMount() {
		this.props.model.on(`change:${this.props.modelProp}`, this.handleModelChange, this);
		this.setupValidation();
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Clean up event listeners properly.
	 */
	componentWillUnmount() {
		this.props.model.off(`change:${this.props.modelProp}`, this.handleModelChange, this);
		this.props.model.off('validate:prop', this.triggerFieldValidation, this);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Setup _invalidProps on the model. Determine if we are already
	 * in a valid state, if not add the invalid prop to the _invalidProps
	 * array. This is then used to prevent saving a model that does not
	 * currently hold a valid state.
	 *
	 * If no value exists in state we use an empty string to pass through
	 * validation.
	 *
	 * The reason for using an empty string is that default value of input
	 * and other form fields in html is empty string, and these fields
	 * will always be empty unless the model already has a value initially.
	 *
	 */
	setupValidation() {
		if (!this.isValid(this.getInitialValue())) {
			this.props.model.setInvalidProp(this.props.modelProp);
		}
		this.props.model.on('validate:prop', this.triggerFieldValidation, this);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Get the default/initial value on the model if there is any. If not return
	 * an empty string since this is what the field contains by default. Prefer the value
	 * on the model over the value on the field since this is never used when bluring
	 * the field.
	 *
	 * @return {Boolean}
	 *
	 */
	getInitialValue() {
		const value = (this.shouldRunValidation(this.state.value) ? this.state.value : false) || this.getInitialModelValue();
		return this.props.model.has(this.props.modelProp) ? this.getInitialModelValue() : value;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * If the model has the prop of the field, return an initial default value.
	 *
	 * @return {Boolean}
	 *
	 */
	getInitialModelValue() {
		const propertyExists = this.props.model.has(this.props.modelProp);
		return propertyExists ? this.props.model.get(this.props.modelProp) : false;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Once a change is detected in the model, update the state of the component (UI)
	 *
	 * @return {undefined}
	 *
	 */
	handleModelChange() {
		this.setState({ value: getFieldValue(this.props.model.get(this.props.modelProp)) });
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Once we detect any user input, update the state of the component (UI)
	 * Note, here we only update state, not the model since this event fires once per each
	 * key event, we avoid slowdowns because of multiple set operations on the model.
	 *
	 * Always set messages to empty array since only the blur event can generate messages
	 * via isValid() .
	 *
	 */
	handleUserInput() {
		const value = getFieldValue(!this.state.value);
		const isValid = !this.props.required;
		this.setState({ value, isValid });

		if (this.runValidators(this.getValidators(), value)) {
			this.props.onModelSync(this.props.model, this.props.modelProp, value);
		}
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Compute the value on the fly, prefer the checkbox state over the model since
	 * we update the checkbox more often than the model (onChange) fires on each
	 * key event. Always return a string (Could otherwise be null or undefined),
	 * those should be represented as empty strings.
	 *
	 * @return {Boolean}
	 *
	 */
	getComputedValue() {
		const value = getFieldValue(this.props.model.get(this.props.modelProp));
		return (value !== null || value !== undefined) ? value : this.state.value;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Triggered via "validate:prop" on the model. Will only run the validators
	 * if the model prop matches the prop that the field is bound to via databinidng.
	 *
	 * @param {Array} exclude Array of props to exclude from validation
	 * @return {undefined}
	 *
	 */
	triggerFieldValidation(exclude) {
		if (exclude.indexOf(this.props.modelProp) !== -1) {
			return;
		}
		this.resetValidationMessages();
		this.runValidators(this.getValidators(), this.getInitialValue());
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Checks if this field is specified as being required, if so
	 * we run the required validation to see if we have any value.
	 *
	 * @param {String} value
	 *
	 * @return {Function} Boolean|String
	 *
	 */
	validateRequiredField(value) {
		const hasRequired = this.props.required;
		const valueIsBoolOrNumber = _.isNumber(value) || _.isBoolean(value);
		const valueIsString = _.isString(value) && value.length > 0;
		const hasValue = valueIsString || valueIsBoolOrNumber;
		return () => {
			if (!hasRequired) {
				return true;
			}
			return hasValue ? true : gettext`Detta fält får inte vara tomt`;
		};
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Runs custom validation on this field if there is any.
	 *
	 * @param {String} value
	 *
	 * @return {Boolean} Boolean
	 */
	validateCustomField(value) {
		return this.props.validate ? this.props.validate(value) : true;
	}


	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Generates a list of validators to be used for this field
	 *
	 * @return {Array}
	 *
	 */
	getValidators() {
		const v = [];

		v.push({
			fn: this.validateRequiredField.bind(this),
			type: 'internal'
		});

		v.push({
			fn: this.validateCustomField.bind(this),
			type: 'internal'
		});

		if (this.hasModelValidator()) {
			v.push({
				fn: this.props.model.validators[this.props.validator].bind(this.props.model),
				type: 'external'
			});
		}
		return v;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Updates the list of props and statuses with the prop associated
	 * to this specific field/instance and its valid state.
	 *
	 * @param {Boolean} isValid current state of the field
	 *
	 * @return {Array}
	 *
	 */
	setModelValidity(isValid) {
		if (isValid) {
			return this.props.model.unsetInvalidProp(this.props.modelProp);
		}
		return this.props.model.setInvalidProp(this.props.modelProp);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Returns an array of all failed validations (Error messages)
	 * Updates the current state based on these validations, having nothing in the
	 * array means we passed validation.
	 *
	 * @param {Array} validators
	 * @param {Boolean} value
	 *
	 *
	 * @return {Array}
	 *
	 */
	runValidators(validators, value) {
		if (!this.shouldRunValidation(value)) {
			// If validation should not be called,
			// the model can't be invalid (the field is empty and not required)
			this.props.model.unsetInvalidProp(this.props.modelProp);
			return [];
		}

		const validationResult = this.getValidationArray(validators, value);
		const isValid = validationResult.length === 0;

		this.setModelValidity(isValid);
		this.setState({ isValid, messages: validationResult });

		return validationResult;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Check if the model
	 *
	 *
	 * @return {bool}
	 *
	 */
	isEmptyModelProp() {
		const value = this.props.model.get(this.props.modelProp);
		const isEmptyString = (_.isString(value) && value.length === 0);
		const isNull = (value === null);
		const isUndefined = (value === undefined);
		return (isEmptyString || isNull || isUndefined);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Reset any dangling validation messages before
	 * rerunning the validation. When the model is empty
	 * the validators wont run, in this case previous messages
	 * should be erased.
	 *
	 *
	 * @return {void}
	 *
	 */
	resetValidationMessages() {
		if (this.state.messages.length === 0 || !this.isEmptyModelProp()) {
			return;
		}
		this.setState({ messages: [] });
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Returns an array containing all failed validations
	 * in the form of strings (messages). If all validation
	 * passes the length of the array will be 0.
	 *
	 * If there is a custom/external validator run it.
	 *
	 * @param {Array} validators
	 * @param {Boolean} value
	 *
	 *
	 * @return {Array}
	 *
	 */
	getValidationArray(validators, value) {
		return validators.map(
			validator => (validator.hasOwnProperty('external') ? validator.fn(value) : validator.fn(value))
		).filter(v => _.isString(v));
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 * Only run validation if the field is not empty
	 * or if the field is required
	 *
	 * @param {Boolean} value
	 * @return {Boolean}
	 *
	 */
	shouldRunValidation(value) {
		const isNotBoolean = value !== false || value !== true;
		const isNotRequired = !this.props.required;
		const valueExists = isNotBoolean && isNotRequired;
		return valueExists || !this.props.disabled;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Check if any specific validator was defined and if that validator exists on the model
	 *
	 * @return {Boolean}
	 *
	 */
	hasModelValidator() {
		const model = this.props.model;
		return this.props.hasOwnProperty('validator') && model.validators && model.validators.hasOwnProperty(this.props.validator);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Validate the value using any specific field validation and
	 * any validator from the model. If there is no state yet and
	 * the field is not required, then skip validation.
	 *
	 * @param {Boolean} value
	 *
	 * @return {Boolean}
	 *
	 */
	isValid(value) {
		const shouldNotRunValidation = !this.shouldRunValidation(value);
		const validationMessages = this.getValidationArray(this.getValidators(), value);
		return shouldNotRunValidation ? true : validationMessages.length === 0;
	}

	/**
	 * @private
	 * @memberOf TextFieldNode
	 *
	 * @description
	 *
	 * Get the tooltip align, default: top.
	 *
	 * @return {String}
	 *
	 */
	getTooltipAlign() {
		return `hint--${this.props.tooltipAlign}`;
	}

	/**
	 * @private
	 * @memberOf TextFieldNode
	 *
	 * @description
	 *
	 * Determine if a tooltip was declared
	 *
	 * @return {Boolean}
	 *
	 */
	hasTooltip() {
		return this.hasValidationMessages() || this.props.tooltip !== null;
	}

	/**
	 * @private
	 * @memberOf TextFieldNode
	 *
	 * @description
	 *
	 * Classes of validations and tooltips
	 *
	 * @return {String}
	 *
	 */
	getTooltipClasses() {
		const hintAlignClass = this.hasTooltip() ? `hint ${this.getTooltipAlign()}` : '';
		const errorClass = this.hasValidationMessages() ? 'hint--always hint--error' : '';
		return [hintAlignClass, errorClass].join(' ');
	}

	/**
	 * @private
	 * @memberOf TextFieldNode
	 *
	 * @description
	 *
	 * Determine we have any validation messages
	 *
	 * @return {Boolean}
	 *
	 */
	hasValidationMessages() {
		return this.state.messages.length > 0;
	}

	/**
	 * @private
	 * @memberOf TextFieldNode
	 *
	 * @description
	 *
	 * String of the tooltip or validation messages
	 * Validation should triumph tooltip
	 *
	 * @return {String}
	 *
	 */
	getTooltip() {
		return this.hasValidationMessages() ? this.state.messages[0] : this.props.tooltip;
	}

	render() {
		return (<div
			className={this.getTooltipClasses()}
			data-hint={this.getTooltip()}
			style={{ position: 'relative' }}
		>
			<label>
				<input
					style={{ margin: '0 3px', width: '20px' }}
					type="checkbox"
					className={this.props.className}
					onChange={this.handleUserInput.bind(this)}
					checked={this.state.value}
					disabled={this.props.disabled}
					value={this.getComputedValue()}
				/>
				<span> {this.props.title} </span>
			</label>
		</div>);
	}
}

FieldCheckBox.defaultProps = {
	validate: () => null,
	validator: '',
	title: '',
	className: '',
	disabled: false,
	onModelSync(model, modelProp, value) {
		return model.set(modelProp, value);
	},
	tooltip: null,
	tooltipAlign: 'top',
	required: false
};

FieldCheckBox.propTypes = {
	model: customPropTypes.model.isRequired,
	modelProp: PropTypes.string.isRequired,
	required: PropTypes.bool,
	onModelSync: PropTypes.func,
	className: PropTypes.string,
	validate: PropTypes.func,
	validator: PropTypes.string,
	title: PropTypes.string,
	disabled: PropTypes.bool,
	tooltip: PropTypes.string,
	tooltipAlign: PropTypes.string
};

export default FieldCheckBox;
