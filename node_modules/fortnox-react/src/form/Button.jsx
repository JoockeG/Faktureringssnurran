import React from 'react';
import PropTypes from 'prop-types';
import Spinner from '../view/ViewSpinner';
import _ from '../utils/UnderscoreAdapter';

/**
 * The React Button component.
 *
 *
 * @class
 * @name Button
 *
 * @return {Button}
 */
class Button extends React.Component {

	constructor(props) {
		super(props);
		this.state = {
			isProcessing: false
		};
	}

	componentWillUnmount() {
		this.setState({ isProcessing: false });
	}

	hasPromiseAPI(p) {
		return (_.isObject(p) && p.then && p.catch);
	}

	shouldShowSpinner(p) {
		if (!this.hasPromiseAPI(p)) { return; }
		this.setState({ isProcessing: true });
		p.then(() => this.btnnode && this.setState({ isProcessing: false }));
		p.catch(() => this.btnnode && this.setState({ isProcessing: false }));
	}

	/**
	 * @memberOf Button
	 * @private
	 *
	 * @description
	 * Blur the Button when clicking on it. If the Click-callback generates a promise, then
	 * automatically show a tiny spinner inside the Button until the promise resolves. Clicking
	 * on the Button more times during the time the promise takes will result in no action.
	 *
	 * @returns {undefined}
	 */
	handleClick() {
		this.btnnode.blur();
		if (this.state.isProcessing) { return; }
		this.shouldShowSpinner(this.props.onClick());
	}

	/**
	 * @memberOf Button
	 * @private
	 *
	 * @description
	 * Is any tooltip defined
	 *
	 * @return {Boolean}
	 */
	hasTooltip() {
		return this.props.hasOwnProperty('tooltip');
	}

	/**
	 * @memberOf Button
	 * @private
	 *
	 * @description
	 * Generate a list of classNames(css) to be used when rendering
	 *
	 * @return {String}
	 */
	getClasses() {
		return [
			'button',
			`button-${this.props.color}`,
			this.props.tooltip ? (`hint hint--${this.props.tooltipAlign}`) : '',
			this.props.className
		].join(' ');
	}

	/**
	 * @memberOf Button
	 * @private
	 *
	 * @description
	 * Allow setting any width on the Button
	 *
	 * @return {Object}
	 */
	getStyle() {
		return {
			width: this.props.width,
			height: this.props.height
		};
	}

	getContentStyle() {
		return {
			visibility: this.state.isProcessing ? 'hidden' : 'visible'
		};
	}

	/**
	 * @memberOf Button
	 * @private
	 *
	 * @description
	 * Render the Button
	 *
	 * @return {Object}
	 */
	render() {
		return (
			<button
				ref={(el) => { this.btnnode = el; }}
				style={this.getStyle()}
				className={this.getClasses()}
				onClick={this.handleClick.bind(this)}
				disabled={this.props.disabled}
				data-hint={this.props.tooltip}
			>
				<span style={this.getContentStyle()}>{this.props.children}</span>
				<Spinner isActive={this.state.isProcessing} />
			</button>
		);
	}

}

Button.defaultProps = {
	width: 'auto',
	height: null,
	color: 'gray',
	className: '',
	onClick() { return null; },
	disabled: false,
	tooltipAlign: 'top',
	tooltip: null
};

Button.propTypes = {
	children: PropTypes.node.isRequired,
	width: PropTypes.oneOfType([
		PropTypes.number,
		PropTypes.string
	]),
	height: PropTypes.oneOfType([
		PropTypes.number,
		PropTypes.string
	]),
	color: PropTypes.string,
	className: PropTypes.string,
	onClick: PropTypes.func,
	disabled: PropTypes.bool,
	tooltipAlign: PropTypes.string,
	tooltip: PropTypes.string
};

export default Button;
