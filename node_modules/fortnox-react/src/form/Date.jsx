import React from 'react';
import PropTypes from 'prop-types';
import { t as gettext } from 'c-3po';
import _ from '../utils/UnderscoreAdapter';
import moment from '../utils/MomentAdapter';
import TextFieldNode from './TextFieldNode';
import Datepicker from '../utils/DatePicker';
import customPropTypes from '../utils/PropValidation';
import { isValidDate, isValidMonth, isValidYear } from '../validations/Date';

class FieldDate extends React.Component {

	constructor(props) {
		super(props);
		this.state = {
			value: null,
			messages: [],
			isValid: true,
			datepickerVisible: false,
			now: this.parse(this.props.model.get(this.props.modelProp), {
				now: moment(),
				formats: this.props.nowFormats
			}) || moment()
		};
	}


	/**
	 * Setup listener for changes on model.
	 * @returns {undefined}
	 */
	componentDidMount() {
		this.props.model.on(`change:${this.props.modelProp}`, this.handleModelChange, this);
		this.props.model.on(`change:${this.props.modelProp}`, this.updateNowFromModel, this);
		this.setupValidation();
	}

	componentDidUpdate(prevProps, prevState) {
		if (this.toISOString(this.state.now) !== this.toISOString(prevState.now)) {
			const value = this.toISOString(this.state.now);
			this.handleUserBlur(this.format(value));
		}
	}
	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Only rerender if the value changes.
	 * Requires the use of the following mixins:
	 *
	 *
	 *
	 *
	 * @param {Object} nextProps - Next properties
	 * @param {Object} nextState - Next state
	 *
	 * @return {undefined}
	 *
	 */
	shouldComponentUpdate(nextProps, nextState) {
		return this.state !== nextState || this.props !== nextProps;
	}

	/**
	 * Tear down listener for changes on model.
	 * @returns {undefined}
	 */
	componentWillUnmount() {
		this.props.model.off(`change:${this.props.modelProp}`, this.handleModelChange, this);
		this.props.model.off(`change:${this.props.modelProp}`, this.updateNowFromModel, this);
		this.props.model.off('validate:prop', this.triggerFieldValidation, this);
	}

	/**
	 * Get a fully explicit year, from a year with potentially implicit century
	 * (a year with explicit century will just return itself), with
	 * consideration of the given now. The closest century to now will be
	 * returned. For example, if now has the year 2001 and year is 5, 2005 will be
	 * returned. If centuries are equally close to now, the smallest century will
	 * be returned.
	 *
	 * @param {Number} year - Year with or without implicit century.
	 * @param {Object} now - Moment.js instance.
	 * @return {Number} Full year.
	 */
	getCentury(year, now) {
		let string = year.toString();
		if (string.length <= 2) {
			if (string.length === 1) { string = `0${string}`; }
			const century = parseInt(now.year().toString().slice(0, 2), 10);
			return _.sortBy(
				_.map([century - 1, century, century + 1], c => parseInt(c + string, 10)),
				y => Math.abs(now.year() - y)
			)[0];
		}
		return year;
	}

	/**
	 * Replace null values in the input array with numbers, representing the
	 * implicit value.
	 *
	 * @param {Array<Number|null>} date - Date, with potentially implicit (null) items.
	 * @param {Object} now - Moment.js instance.
	 * @return {Array<Number>} Fully explicit date.
	 */
	insertImplicits(date, now) {
		const implicits = date[0] ? [now.year(), 1, 1] : [now.year(), now.month() + 1, 1];
		const d = _.map(_.zip(date, implicits), x => _.isNull(x[0]) ? x[1] : x[0]);
		const end = moment([d[0], d[1]]).add(-1, 'days');
		if (!moment([d[0], d[1] - 1, d[2]]).isValid() && end.isValid() && d[2] < 32) {
			d[2] = end.date();
		}
		return d;
	}

	/**
	 * Check if the given character is present in format.
	 *
	 * @param {String} format - String to look in.
	 * @param {String} c - Character to look for.
	 * @return {Boolean} true if match found, otherwise false.
	 */
	isActiveCharacter(format, c) {
		return !!format.match(c);
	}

	/**
	 * Match format on string and convert the overlapping characters to a
	 * number. Return null if no number can be determined.
	 *
	 * @param {String} format - Format to match on.
	 * @param {String} c - Character to look for.
	 * @param {String} string - String with numbers.
	 * @return {Number|null} Matching number.
	 */
	characterToNumber(format, c, string) {
		if (!this.isActiveCharacter(format, c)) { return null; }
		const ms = string.match(`^${format.replace(new RegExp(`[^${c}-]`, 'g'), '.').replace(new RegExp(c, 'g'), '(\\d)')}$`);
		return ms ? parseInt(_.rest(ms).join(''), 10) : null;
	}
	/**
	 * Take a string representing a date and unformat it (convert to array)
	 * according to the given format.
	 *
	 * @param {String} format - Format to use.
	 * @param {String} string - String to be unformatted.
	 * @param {Object} now - Moment.js instance.
	 * @return {Array<Number|null>} Unformatted date.
	 */
	unformat(format, string, now) {
		if (format.length !== string.length) { return null; } // Performance optimization.
		const implicitYear = this.characterToNumber(format, 'Y', string);
		const year = _.isFinite(implicitYear) ? this.getCentury(implicitYear, now) : null;
		const month = this.characterToNumber(format, 'M', string);
		const date = this.characterToNumber(format, 'D', string);

		if (isValidYear(format, year, now) && isValidMonth(format, month) && isValidDate(format, date)) {
			return [year, month, date];
		}
		return null;
	}

	/**
	 * Sanitize input string and convert string items to integers.
	 *
	 * @param {String} string - String to be normalized.
	 * @param {Object} now - Moment.js instance.
	 * @param {Array} formats
	 * @return {Array<Number|null>} Normalized date.
	 */
	normalize(string, now, formats) {
		const n = (string || '').replace(/[^0-9]/g, '-').replace(/(^-+)|(-+$)/g, '').replace(/-{2,}/g, '-');
		if (!n) { return null; }
		return _.reduce(formats, _.bind(function (x, f) {
			return x || this.unformat(f, n, now);
		}, this), null);
	}

	/**
	 * Take a string holding a date in "human form" and return a Moment.js
	 * instance with the same date semantics. For example, the string
	 * "2001-01-01" would create a Moment.js instance representing year 2001,
	 * month 0 (zero-based) and date 1.
	 *
	 * If the parsed string is not valid, null will be returned.
	 *
	 * @param {String|null} string - String to be parsed.
	 * @param {Object} [opts] - "now" is a Moment.js instance. "formats" is an array of date formats.
	 * @return {Object|null} Moment.js instance or null.
	 */
	parse(string, opts = {}) {
		const now = opts.now || moment();
		const formats = opts.formats || this.props.formats;
		const normalized = this.normalize(string, now, formats);
		if (!normalized) { return null; }
		const date = this.insertImplicits(normalized, now);
		return moment([date[0], date[1] - 1, date[2]]);
	}

	/**
	 * Increase the given date by n days.
	 *
	 * @param {String} string - String to be parsed.
	 * @param {Number} n - Number to increase (may be negative for decrement).
	 * @return {Object} Moment.js instance.
	 */
	increaseDate(string, n) {
		const date = this.parse(string, { now: this.state.now });
		return date ? date.add(n, 'days') : null;
	}

	/**
	 * @description
	 * Return the current state of the given date as a string in the ISO 8601
	 * calendar date format (YYYY-MM-DD).
	 * If the date is falsey, an empty string will be returned instead.
	 *
	 * @param {Object} date
	 *
	 * @return {Object|String} Moment.js instance or an empty string.
	 */
	toISOString(date) {
		return date.format('YYYY-MM-DD');
	}

	/**
	 * For now, the date field is always valid.
	 *
	 * @return {Boolean} true.
	 */
	validate() {
		return true;
	}

	/**
	 * Toggle datepicker visibility and set focus on the input field.
	 *
	 * @param {Event} e - Event object.
	 *
	 * @returns {undefined}
	 */
	toggleDatepicker(e) {
		if (this.props.disabled) { return null; }
		e.preventDefault();
		this.container.querySelector('input').focus();
		return this.setState({
			datepickerVisible: !this.state.datepickerVisible
		});
	}

	/**
	 * Format the given value with the toISOString method, to be shown in
	 * the textfield.
	 *
	 * @param {String} value - Date to format.
	 * @return {String|*} String if value is truthy, otherwise value.
	 */
	format(value) {
		return value ? this.toISOString(this.props.alterDate(this.parse(value) || this.state.now)) : value;
	}

	/**
	 * Use the same format on the model, where typeCast method is called
	 * in case we need to modify the original value, which we do in this case.
	 *
	 * @param {String} value - Date to format.
	 * @return {String|*} String if value is truthy, otherwise value.
	 */
	typeCast(value) {
		return this.format(value);
	}

	/**
	 * Go forward and backward by one date using the up and down arrow keys.
	 *
	 * @param {Event} e - Event object.
	 * @param {String} value - Date string.
	 *
	 * @returns {undefined}
	 */
	stepDate(e, value) {
		if (_.contains([38, 40], e.which)) {
			const date = this.increaseDate(value, e.which === 38 ? 1 : -1);
			if (date) {
				this.setState({ now: date, value: this.toISOString(date) });
			}
			e.preventDefault();
		}
	}

	/**
	 * Prevent input to the input element if the requested input character is
	 * not any of the character "0-9", "-", "/", or " " (space) or if the input
	 * character is associated with the Control or Meta keys.
	 *
	 * @param {Event} e - Event object.
	 *
	 * @returns {undefined}
	 */
	filterInput(e) {
		if (_.contains(_.union([0, 8, 32], _.range(45, 58)), e.which)) { return; }
		if (e.ctrlKey || e.metaKey) { return; }
		e.preventDefault();
	}

	/**
	 * Update the now state with the current value in the input element.
	 *
	 * @param {String} value - Date string.
	 *
	 * @returns {undefined}
	 */
	input(value) {
		const date = this.parse(value, {
			now: this.state.now,
			formats: this.props.nowFormats
		});
		if (date) {
			this.setState({ now: date });
		}
		this.handleUserInput.apply(this, arguments);
	}

	/**
	 * Cleanup when the input element is blurred.
	 *
	 * @param {String} value - Date string.
	 *
	 * @returns {undefined}
	 */
	blur(value) {
		this.setState({ datepickerVisible: false });
		this.handleUserBlur.apply(this, [this.format(value)]);
		const date = this.parse(value, { now: this.state.now });
		if (date) {
			this.setState({ now: date });
		}
	}

	/**
	 * Update state when a date is picked in the datepicker.
	 *
	 * @param {Object} date - Moment.js instance.
	 *
	 * @returns {undefined}
	 */
	pickDate(date) {
		const d = moment(date);
		const value = this.toISOString(d);
		this.setState({
			datepickerVisible: false,
			now: d,
			value
		});
	}

	/**
	 * Synchronize "now" state with model.
	 *
	 * @returns {undefined}
	 */
	updateNowFromModel() {
		const date = this.parse(this.props.model.get(this.props.modelProp), {
			now: moment(),
			formats: this.props.nowFormats
		});
		if (date) {
			this.setState({ now: date });
		}
	}

	/**
	 * Generate the actual datepicker Popover
	 *
	 * @returns {Object} React Elements
	 */

	getDatePicker() {
		if (!this.state.datepickerVisible) { return null; }
		return (<Datepicker
			alterDateTypes={this.props.alterDateTypes}
			initialYear={this.state.now.year()}
			initialMonth={this.state.now.month()}
			onPick={this.pickDate.bind(this)}
		/>);
	}


	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Setup _invalidProps on the model. Determine if we are already
	 * in a valid state, if not add the invalid prop to the _invalidProps
	 * array. This is then used to prevent saving a model that does not
	 * currently hold a valid state.
	 *
	 * If no value exists in state we use an empty string to pass through
	 * validation.
	 *
	 * The reason for using an empty string is that default value of input
	 * and other form fields in html is empty string, and these fields
	 * will always be empty unless the model already has a value initially.
	 *
	 * @return {void}
	 *
	 */
	setupValidation() {
		if (!this.isValid(this.getInitialValue())) {
			this.props.model.setInvalidProp(this.props.modelProp);
		}
		this.props.model.on('validate:prop', this.triggerFieldValidation, this);
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Get the default/initial value on the model if there is any. If not return
	 * an empty string since this is what the field contains by default.
	 *
	 * @return {Mixed} String|*
	 *
	 */
	getInitialValue() {
		return this.getInitialModelValue() || (this.state.value ? this.state.value : '');
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * If the model has the prop of the field, return an initial default value.
	 *
	 * @return {Mixed} undefined|*
	 *
	 */
	getInitialModelValue() {
		return this.props.model.has(this.props.modelProp) ? this.props.model.get(this.props.modelProp) : undefined;
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * typeCasts and returns the value if any typeCasting was defined, otherwise
	 * returns the original value.
	 *
	 * @param {String} value
	 *
	 * @return {Mixed}
	 *
	 */
	getModelValue(value) {
		if (this.hasTypeCasting()) {
			return this.props.typeCast(value);
		}
		return value;
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Formats the value according to a specific formatter if any was
	 * defined, otherwise returns the original value.
	 *
	 * @param {Mixed} value
	 *
	 * @return {String}
	 *
	 */
	getFieldValue(value) {
		if (this.hasFieldFormatter()) {
			return this.props.format(value);
		}
		return value;
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Once a change is detected in the model, update the state of the component (UI)
	 *
	 * @return {undefined}
	 *
	 */
	handleModelChange() {
		this.setState({ value: this.getFieldValue(this.props.model.get(this.props.modelProp)) });
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Once we detect any user input, update the state of the component (UI)
	 * Note, here we only update state, not the model since this event fires once per each
	 * keyevent, we avoid slowdowns because of multiple set operations on the model.
	 *
	 * Always set messages to empty array since only the blur event can generate messages
	 * via isValid() .
	 *
	 * @param {String} value
	 *
	 * @return {undefined}
	 *
	 */
	handleUserInput(value) {
		this.setState({ value, messages: [] });
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Compute the value on the fly, prefer the textbox state over the model since
	 * we update the textbox more often than the model (onChange) fires on each
	 * key event. Always return a string (Could otherwise be null or undefined),
	 * those should be represented as empty strings.
	 *
	 * @return {String}
	 *
	 */
	getComputedValue() {
		const value = this.state.value !== null ? this.state.value : this.props.model.get(this.props.modelProp);
		return value || '';
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Check if the component of this mixin has type casting defined
	 *
	 * @return {Boolean}
	 *
	 */
	hasTypeCasting() {
		return this.props.hasOwnProperty('typeCast');
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Check if the component of this mixin has data formatting options defined
	 *
	 * @return {Boolean}
	 *
	 */
	hasFieldFormatter() {
		return this.props.hasOwnProperty('format');
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Once we detect any user blur event, update the value of the model,
	 * and the state of the component.
	 *
	 * @param {String} value
	 *
	 * @return {undefined}
	 *
	 */
	handleUserBlur(value) {
		this.setState({ value: this.getFieldValue(value) });
		if (this.runValidators(this.getValidators(), value)) {
			return this.props.onModelSync(this.props.model, this.props.modelProp, this.getModelValue(value));
		}
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Triggered via "validate:prop" on the model. Will only run the validators
	 * if the model prop matches the prop that the field is bound to via databinidng.
	 *
	 * @param {Array} exclude
	 *
	 * @return {Mixed} String|*
	 *
	 */
	triggerFieldValidation(exclude) {
		if (exclude.indexOf(this.props.modelProp) !== -1) { return; }
		this.runValidators(this.getValidators(), this.getInitialValue());
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Checks if this field is specified as being required, if so
	 * we run the required validation to see if we have any value.
	 *
	 * @param {String} value
	 *
	 * @return {Mixed} Boolean|String
	 *
	 */
	validateRequiredField(value) {
		const hasRequired = this.props.required;
		const hasValue = (_.isString(value) && value.length > 0 || _.isNumber(value) || _.isBoolean(value));
		return (function () {
			if (!hasRequired) { return true; }
			return hasValue ? true : gettext`Detta fält får inte vara tomt`;
		}());
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Runs custom validation on this field if there is any.
	 *
	 * @param {String} value
	 *
	 * @return {Mixed} Boolean|String
	 *
	 */
	validateCustomField(value) {
		return this.props.validate ? this.props.validate(value) : true;
	}


	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Generates a list of validators to be used for this field
	 *
	 * @return {Array}
	 *
	 */
	getValidators() {
		const v = [
			this.validateRequiredField.bind(this),
			this.validateCustomField.bind(this)
		];
		if (this.hasModelValidator()) {
			v.push(this.props.model.validators[this.props.validator].bind(this.props.model));
		}
		return v;
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Returns an array of all failed validations (Error messages)
	 * Updates the current state based on these validations, having nothing in the
	 * array means we passed validation.
	 *
	 * @param {Array} validators
	 * @param {String} value
	 *
	 *
	 * @return {Array}
	 *
	 */
	runValidators(validators, value) {
		if (!this.shouldRunValidation(value)) {
			return [];
		}

		const arr = this.getValidationArray(validators, value);
		const nextState = {
			isValid: arr.length === 0,
			messages: arr
		};

		this.updateModelValidationStatus(nextState.isValid);
		this.setState(nextState);

		return arr;
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Updates the list of props and statuses with the prop associated
	 * to this specific field/instance and its valid state.
	 *
	 * @param {Boolean} isValid current state of the field
	 *
	 * @return {Array}
	 *
	 */
	updateModelValidationStatus(isValid) {
		if (isValid) {
			return this.props.model.unsetInvalidProp(this.props.modelProp);
		}
		return this.props.model.setInvalidProp(this.props.modelProp);
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Returns an array containing all failed validations
	 * in the form of strings (messages). If all validation
	 * passes the length of the array will be 0.
	 *
	 * @param {Array} validators
	 * @param {String} value
	 *
	 *
	 * @return {Array}
	 *
	 */
	getValidationArray(validators, value) {
		return validators.map(fn => fn(value)).filter(v => _.isString(v));
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * If there is no state yet and the field is
	 * not required, then skip validation. The string check is
	 * required because !emptystring produces a falsy value.
	 * However, empty string should be a valid value and
	 * always pass through validation.
	 *
	 * @param {String} value
	 *
	 * @return {Boolean}
	 *
	 */
	shouldRunValidation(value) {
		if (!value && !_.isString(value) && !this.props.required) {
			return false;
		}
		return true;
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Check if any specific validator was defined and if that validator exists on the model
	 *
	 * @return {Boolean}
	 *
	 */
	hasModelValidator() {
		const model = this.props.model;
		return this.props.hasOwnProperty('validator') && model.validators && model.validators.hasOwnProperty(this.props.validator);
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Validate the value using any specific field validation and
	 * any validator from the model. If there is no state yet and
	 * the field is not required, then skip validation.
	 *
	 * @param {String} value
	 *
	 * @return {Boolean}
	 *
	 */
	isValid(value) {
		if (!this.shouldRunValidation()) {
			return true;
		}
		return this.getValidationArray(this.getValidators(), value).length === 0;
	}

	/**
	 * @private
	 * @memberOf FieldDate
	 *
	 * @description
	 *
	 * Generate title of the input field
	 *
	 *
	 * @return {Object}
	 *
	 */
	getTitle() {
		if (!this.props.title) { return null; }
		return <label>{this.props.title}{this.props.children}</label>;
	}

	/**
	 * Render date field.
	 *
	 * @return {Object} Date field as <div> React component.
	 */
	render() {
		return (
			<div ref={(el) => { this.container = el; }} className="datepicker-container">
				<label>{this.props.title}</label>
				<TextFieldNode
					value={this.getComputedValue()}
					maxlength={this.props.maxlength}
					disabled={this.props.disabled}
					onUserBlur={this.blur.bind(this)}
					onKeyDown={this.stepDate.bind(this)}
					onKeyPress={this.filterInput.bind(this)}
					onUserInput={this.input.bind(this)}
					isValid={this.state.isValid}
					className={this.props.className}
					tooltipAlign={this.props.tooltipAlign}
					tooltip={this.props.tooltip}
					messages={this.state.messages}
					autoFocus={this.props.autoFocus}
					icon={<i className="fa fa-calendar" onMouseDown={this.toggleDatepicker.bind(this)} />}
				/>
				{this.getDatePicker()}
			</div>
		);
	}

}


FieldDate.defaultProps = {
	onModelSync(model, modelProp, value) {
		return model.set(modelProp, value);
	},
	alterDate: _.identity,
	alterDateTypes(types) { return types; },
	autoFocus: false,
	formats: [
		'D', 'DD', 'YY', 'MDD', 'MMD', 'YMD', 'MMDD', 'YYMM', 'YYYY', 'YMMDD', 'YYMDD', 'YYMMD', 'YYMMDD', 'YYYMDD', 'YYYMMD', 'YYYYMM', 'YYYYMDD', 'YYYYMMD', 'YYYMMDD', 'YYYYMMDD',
		'M-D', 'M-DD', 'MM-D', 'YY-M', 'Y-MDD', 'Y-MMD', 'MM-DD', 'YY-MM', 'YY-MD', 'YMM-D', 'YYM-D', 'Y-MMDD', 'YY-MDD', 'YY-MMD', 'YMM-DD', 'YYM-DD', 'YYY-MM', 'YYY-MD', 'YYYY-M', 'YYMM-D', 'YY-MMDD', 'YYYY-MM', 'YYYY-MD', 'YYY-MMDD', 'YYYY-MDD', 'YYYY-MMD', 'YYYYMM-D', 'YYYY-MMDD', 'YYYYMM-DD',
		'Y-M-D', 'Y-M-DD', 'Y-MM-D', 'YY-M-D', 'Y-MM-DD', 'YY-M-DD', 'YY-MM-D', 'YYY-M-D', 'YY-MM-DD', 'YYY-M-DD', 'YYY-MM-D', 'YYYY-M-D', 'YYY-MM-DD', 'YYYY-M-DD', 'YYYY-MM-D', 'YYYY-MM-DD'
	],
	nowFormats: ['YY-MM-D', 'YY-MM-DD', 'YYYY-MM-DD']
};

FieldDate.propTypes = {
	alterDate: PropTypes.func,
	alterDateTypes: PropTypes.func,
	autoFocus: PropTypes.bool,
	modelProp: PropTypes.string,
	onModelSync: PropTypes.func.isRequired,
	model: customPropTypes.model,
	title: PropTypes.string,
	maxlength: PropTypes.number,
	disabled: PropTypes.bool,
	className: PropTypes.string,
	tooltipAlign: PropTypes.string,
	tooltip: PropTypes.string,
	formats: PropTypes.array,
	nowFormats: PropTypes.array,
	typeCast: PropTypes.func,
	format: PropTypes.func,
	required: PropTypes.bool,
	validate: PropTypes.func,
	validator: PropTypes.string
};


export default FieldDate;
