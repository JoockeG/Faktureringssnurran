import React from 'react';
import PropTypes from 'prop-types';
import { t as gettext } from 'c-3po';
import _ from '../utils/UnderscoreAdapter';
import customPropTypes from '../utils/PropValidation';

/**
 * The React TextAreaNode component.
 *
 *
 * @class
 * @name TextAreaNode
 *
 * @return {TextAreaNode} An instance of the TextAreaNode component.
 */
class TextAreaNode extends React.Component {

	/**
	 * @private
	 * @memberOf TextAreaNode
	 *
	 * @description
	 * Resize rerender when props change
	 *
	 * @param {Object} nextProps
	 *
	 * @return {Boolean}
	 */
	componentDidMount() {
		this.resize();
	}

	/**
	 * @private
	 * @memberOf TextAreaNode
	 *
	 * @description
	 *
	 * Only rerender when props change
	 *
	 * @param {Object} nextProps
	 *
	 * @return {Boolean}
	 */
	shouldComponentUpdate(nextProps) {
		return this.props !== nextProps;
	}

	/**
	 * @private
	 * @memberOf TextAreaNode
	 *
	 * @description
	 *
	 * Handle the change event, call parent to update state
	 *
	 * @return {undefined}
	 */
	handleChange() {
		this.props.onUserInput(this.el.value);
		this.resize();
	}

	resize() {
		if (this.props.autoResize) {
			const textarea = this.el; // scope it

			const css = (property) => {
				const style = window.getComputedStyle(textarea);
				return parseInt(style.getPropertyValue(property), 10);
			};

			textarea.rows = this.props.minRows; // erase rows to force scrollHeight recalculation

			const padding = css('padding-top') + css('padding-bottom');
			const rows = (textarea.scrollHeight - padding) / css('line-height'); // line-height should be specified for textarea

			textarea.rows = Math.max(this.props.minRows, Math.min(rows, this.props.maxRows));
		}
	}

	/**
	 * @private
	 * @memberOf TextAreaNode
	 *
	 * @description
	 *
	 * Handle the change event, call parent to update the model
	 *
	 * @return {undefined}
	 */
	handleBlur() {
		this.props.onUserBlur(this.el.value);
	}

	/**
	 * @private
	 * @memberOf TextAreaNode
	 *
	 * @description
	 *
	 * Determine we have any validation messages
	 *
	 * @return {Boolean}
	 *
	 */
	hasValidationMessages() {
		return this.props.messages.length > 0;
	}

	/**
	 * @private
	 * @memberOf TextAreaNode
	 *
	 * @description
	 *
	 * Determine if a tooltip was declared
	 *
	 * @return {Boolean}
	 *
	 */
	hasTooltip() {
		return this.hasValidationMessages() || this.props.tooltip !== null;
	}

	/**
	 * @private
	 * @memberOf TextAreaNode
	 *
	 * @description
	 *
	 * Get the tooltip align, default: top.
	 *
	 * @return {String}
	 *
	 */
	getTooltipAlign() {
		return `hint--${this.props.tooltipAlign}`;
	}

	/**
	 * @private
	 * @memberOf TextAreaNode
	 *
	 * @description
	 *
	 * Classes of validations and tooltips
	 *
	 * @return {String}
	 *
	 */
	getTooltipClasses() {
		return [
			this.hasTooltip() ? `hint ${this.getTooltipAlign()}` : '',
			this.hasValidationMessages() ? 'hint--always hint--error' : ''
		].join(' ');
	}

	/**
	 * @private
	 * @memberOf TextAreaNode
	 *
	 * @description
	 *
	 * String of the tooltip or validation messages
	 * Validation should triumph tooltip
	 *
	 * @return {String}
	 *
	 */
	getTooltip() {
		if (this.hasValidationMessages()) {
			return this.props.messages[0];
		}
		return this.props.tooltip;
	}

	/**
	 * @private
	 * @memberOf TextAreaNode
	 *
	 * @description
	 *
	 * Renders the textarea node
	 *
	 * @return {Object} - React internals
	 */
	render() {
		return (
			<div
				className={this.getTooltipClasses()}
				data-hint={this.getTooltip()}
				style={{ position: 'relative' }}
			>
				<textarea
					maxLength={this.props.maxLength}
					placeholder={this.props.placeholder}
					value={this.props.value}
					onChange={this.handleChange.bind(this)}
					onBlur={this.handleBlur.bind(this)}
					disabled={this.props.disabled}
					ref={(el) => { this.el = el; }}
					className={this.props.className}
					rows={this.props.minRows}
					cols={this.props.cols}
					autoFocus={this.props.autoFocus}
				/>
			</div>
		);
	}

}

TextAreaNode.defaultProps = {
	tooltip: null
};

TextAreaNode.propTypes = {
	messages: PropTypes.array.isRequired,
	tooltip: PropTypes.string,
	tooltipAlign: PropTypes.string.isRequired,
	onUserInput: PropTypes.func,
	onUserBlur: PropTypes.func,
	placeholder: PropTypes.string,
	value: PropTypes.string,
	className: PropTypes.string,
	maxLength: PropTypes.oneOfType([
		PropTypes.string,
		PropTypes.number
	]),
	autoResize: PropTypes.bool,
	minRows: PropTypes.number,
	maxRows: PropTypes.number,
	cols: PropTypes.number,
	autoFocus: PropTypes.bool,
	disabled: PropTypes.bool
};


/**
 * The React FormFieldTextArea component.
 *
 *
 * @class
 * @name FormFieldTextArea
 *
 * @return {FormFieldTextArea} An instance of the FormFieldTextArea component.
 */
class FieldTextArea extends React.Component {

	constructor(props) {
		super(props);
		this.state = {
			value: null,
			messages: [],
			isValid: true
		};
	}

	componentDidMount() {
		this.props.model.on(`change:${this.props.modelProp}`, this.handleModelChange, this);
		this.setupValidation();
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 * Only rerender if the props or state changes
	 *
	 * @param {Object} nextProps - Next properties
	 * @param {Object} nextState - Next state
	 *
	 * @return {undefined}
	 *
	 */
	shouldComponentUpdate(nextProps, nextState) {
		return this.state !== nextState || this.props !== nextProps;
	}

	componentWillUnmount() {
		this.props.model.off(`change:${this.props.modelProp}`, this.handleModelChange, this);
		this.props.model.off('validate:prop', this.triggerFieldValidation.bind(this));
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Setup _invalidProps on the model. Determine if we are already
	 * in a valid state, if not add the invalid prop to the _invalidProps
	 * array. This is then used to prevent saving a model that does not
	 * currently hold a valid state.
	 *
	 * If no value exists in state we use an empty string to pass through
	 * validation.
	 *
	 * The reason for using an empty string is that default value of input
	 * and other form fields in html is empty string, and these fields
	 * will always be empty unless the model already has a value initially.
	 *
	 * @return {void}
	 *
	 */
	setupValidation() {
		if (!this.isValid(this.getInitialValue())) {
			this.props.model.setInvalidProp(this.props.modelProp);
		}
		this.props.model.on('validate:prop', this.triggerFieldValidation, this);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Get the default/initial value on the model if there is any. If not return
	 * an empty string since this is what the field contains by default.
	 *
	 * @return {Mixed} String|*
	 *
	 */
	getInitialValue() {
		return this.getInitialModelValue() || (this.state.value ? this.state.value : '');
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * If the model has the prop of the field, return an initial default value.
	 *
	 * @return {Mixed} undefined|*
	 *
	 */
	getInitialModelValue() {
		return this.props.model.has(this.props.modelProp) ? this.props.model.get(this.props.modelProp) : undefined;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * typeCasts and returns the value if any typeCasting was defined, otherwise
	 * returns the original value.
	 *
	 * @param {String} value
	 *
	 * @return {Mixed}
	 *
	 */
	getModelValue(value) {
		if (this.hasTypeCasting()) {
			return this.props.typeCast(value);
		}
		return value;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Formats the value according to a specific formatter if any was
	 * defined, otherwise returns the original value.
	 *
	 * @param {Mixed} value
	 *
	 * @return {String}
	 *
	 */
	getFieldValue(value) {
		if (this.hasFieldFormatter()) {
			return this.props.format(value);
		}
		return value;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Once a change is detected in the model, update the state of the component (UI)
	 *
	 * @return {undefined}
	 *
	 */
	handleModelChange() {
		this.setState({ value: this.getFieldValue(this.props.model.get(this.props.modelProp)) });
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Once we detect any user input, update the state of the component (UI)
	 * Note, here we only update state, not the model since this event fires once per each
	 * keyevent, we avoid slowdowns because of multiple set operations on the model.
	 *
	 * Always set messages to empty array since only the blur event can generate messages
	 * via isValid() .
	 *
	 * @param {String} value
	 *
	 * @return {undefined}
	 *
	 */
	handleUserInput(value) {
		this.setState({ value, messages: [] });
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Compute the value on the fly, prefer the textbox state over the model since
	 * we update the textbox more often than the model (onChange) fires on each
	 * key event. Always return a string (Could otherwise be null or undefined),
	 * those should be represented as empty strings.
	 *
	 * @return {String}
	 *
	 */
	getComputedValue() {
		const value = this.state.value !== null ? this.state.value : this.props.model.get(this.props.modelProp);
		return value || '';
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Check if the component of this mixin has type casting defined
	 *
	 * @return {Boolean}
	 *
	 */
	hasTypeCasting() {
		return this.props.hasOwnProperty('typeCast');
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Check if the component of this mixin has data formatting options defined
	 *
	 * @return {Boolean}
	 *
	 */
	hasFieldFormatter() {
		return this.props.hasOwnProperty('format');
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Once we detect any user blur event, update the value of the model,
	 * and the state of the component.
	 *
	 * @param {String} value
	 *
	 * @return {undefined}
	 *
	 */
	handleUserBlur(value) {
		this.setState({ value: this.getFieldValue(value) });

		if (this.runValidators(this.getValidators(), value)) {
			this.props.model.set(this.props.modelProp, this.getModelValue(value));
		}
		this.props.onUserBlur(value);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Triggered via "validate:prop" on the model. Will only run the validators
	 * if the model prop matches the prop that the field is bound to via databinidng.
	 *
	 * @return {Mixed} String|*
	 *
	 */
	triggerFieldValidation() {
		this.runValidators(this.getValidators(), this.getInitialValue());
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Checks if this field is specified as being required, if so
	 * we run the required validation to see if we have any value.
	 *
	 * @param {String} value
	 *
	 * @return {Mixed} Boolean|String
	 */
	validateRequiredField(value) {
		const hasRequired = this.props.hasOwnProperty('required');
		const hasValue = (_.isString(value) && value.length > 0 || _.isNumber(value) || _.isBoolean(value));
		return (function () {
			if (!hasRequired) { return true; }
			return hasValue ? true : gettext`Detta fält får inte vara tomt`;
		}());
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Runs custom validation on this field if there is any.
	 *
	 * @param {String} value
	 *
	 * @return {Mixed} Boolean|String
	 */
	validateCustomField(value) {
		return this.props.validate ? this.props.validate(value) : true;
	}


	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Generates a list of validators to be used for this field
	 *
	 * @return {Array}
	 *
	 */
	getValidators() {
		const v = [
			this.validateRequiredField.bind(this),
			this.validateCustomField.bind(this)
		];
		if (this.hasModelValidator()) {
			v.push(this.props.model.validators[this.props.validator].bind(this.props.model));
		}
		return v;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Returns an array of all failed validations (Error messages)
	 * Updates the current state based on these validations, having nothing in the
	 * array means we passed validation.
	 *
	 * @param {Array} validators
	 * @param {String} value
	 *
	 *
	 * @return {Array}
	 *
	 */
	runValidators(validators, value) {
		if (!this.shouldRunValidation()) {
			return [];
		}

		const arr = this.getValidationArray(validators, value);

		const nextState = {
			isValid: arr.length === 0,
			messages: arr
		};

		this.updateModelValidationStatus(nextState.isValid);
		this.setState(nextState);

		return arr;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Updates the list of props and statuses with the prop associated
	 * to this specific field/instance and its valid state.
	 *
	 * @param {Boolean} isValid current state of the field
	 *
	 * @return {Array}
	 *
	 */
	updateModelValidationStatus(isValid) {
		if (isValid) {
			return this.props.model.unsetInvalidProp(this.props.modelProp);
		}
		return this.props.model.setInvalidProp(this.props.modelProp);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Returns an array containing all failed validations
	 * in the form of strings (messages). If all validation
	 * passes the length of the array will be 0.
	 *
	 * @param {Array} validators
	 * @param {String} value
	 *
	 *
	 * @return {Array}
	 *
	 */
	getValidationArray(validators, value) {
		return validators.map(fn => fn(value)).filter(v => _.isString(v));
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * If there is no state yet and the field is
	 * not required, then skip validation. The string check is
	 * required because !emptystring produces a falsy value.
	 * However, empty string should be a valid value and
	 * always pass through validation.
	 *
	 *
	 * @return {Boolean}
	 *
	 */
	shouldRunValidation() {
		if (!this.state.value && !_.isString(this.state.value) && !this.props.required) {
			return false;
		}
		return true;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Check if any specific validator was defined and if that validator exists on the model
	 *
	 * @return {Boolean}
	 *
	 */
	hasModelValidator() {
		const model = this.props.model;
		return this.props.hasOwnProperty('validator') && model.validators && model.validators.hasOwnProperty(this.props.validator);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Validate the value using any specific field validation and
	 * any validator from the model. If there is no state yet and
	 * the field is not required, then skip validation.
	 *
	 * @param {String} value
	 *
	 * @return {Boolean}
	 *
	 */
	isValid(value) {
		if (!this.shouldRunValidation()) {
			return true;
		}
		return this.getValidationArray(this.getValidators(), value).length === 0;
	}

	/**
	 * @private
	 * @memberOf FormFieldTextArea
	 *
	 * @description
	 *
	 * Render the textarea field
	 *
	 * @return {Object} - React internals
	 */
	render() {
		return (
			<div>
				<label>{this.props.title}</label>
				<TextAreaNode
					maxLength={this.props.maxLength}
					placeholder={this.props.placeholder}
					value={this.getComputedValue()}
					onUserInput={this.handleUserInput.bind(this)}
					onUserBlur={this.handleUserBlur.bind(this)}
					disabled={this.props.disabled}
					className={this.props.className}
					autoResize={this.props.autoResize}
					minRows={this.props.minRows}
					maxRows={this.props.maxRows}
					cols={this.props.cols}
					autoFocus={this.props.autoFocus}
					messages={this.state.messages}
					isValid={this.state.isValid}
					tooltipAlign={this.props.tooltipAlign}
					tooltip={this.props.tooltip}
				/>
			</div>
		);
	}

}

FieldTextArea.defaultProps = {
	autoResize: false,
	minRows: 1,
	maxRows: 5,
	onUserBlur() {
		return null;
	},
	tooltip: null,
	tooltipAlign: 'top'
};

FieldTextArea.propTypes = {
	model: customPropTypes.model,
	modelProp: PropTypes.string.isRequired,
	typeCast: PropTypes.func,
	format: PropTypes.func,
	title: PropTypes.string,
	placeholder: PropTypes.string,
	className: PropTypes.string,
	required: PropTypes.bool,
	validator: PropTypes.string,
	validate: PropTypes.func,
	maxLength: PropTypes.oneOfType([
		PropTypes.string,
		PropTypes.number
	]),
	disabled: PropTypes.bool,
	autoResize: PropTypes.bool,
	minRows: PropTypes.number,
	maxRows: PropTypes.number,
	cols: PropTypes.number,
	autoFocus: PropTypes.bool,
	onUserBlur: PropTypes.func,
	tooltipAlign: PropTypes.string,
	tooltip: PropTypes.string
};


export default FieldTextArea;
