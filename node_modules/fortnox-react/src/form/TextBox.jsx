import React from 'react';
import PropTypes from 'prop-types';
import { t as gettext } from 'c-3po';
import _ from '../utils/UnderscoreAdapter';
import TextFieldNode from './TextFieldNode';
import customPropTypes from '../utils/PropValidation';

class TextBox extends React.Component {

	constructor(props) {
		super(props);
		this.state = {
			value: null,
			messages: [],
			isValid: true
		};
	}

	/**
	 * Setup events
	 * @return {undefined}
	 */
	componentDidMount() {
		this.props.model.on(`change:${this.props.modelProp}`, this.handleModelChange, this);
		this.setupValidation();
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * @param {Object} nextProps - Next properties
	 * @param {Object} nextState - Next state
	 *
	 * @return {undefined}
	 *
	 */
	shouldComponentUpdate(nextProps, nextState) {
		return this.state !== nextState || this.props !== nextProps;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Clean up eventlisteners properly.
	 *
	 * @return {undefined}
	 */
	componentWillUnmount() {
		this.props.model.off(`change:${this.props.modelProp}`, this.handleModelChange, this);
		this.props.model.off('validate:prop', this.triggerFieldValidation, this);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Setup _invalidProps on the model. Determine if we are already
	 * in a valid state, if not add the invalid prop to the _invalidProps
	 * array. This is then used to prevent saving a model that does not
	 * currently hold a valid state.
	 *
	 * If no value exists in state we use an empty string to pass through
	 * validation.
	 *
	 * The reason for using an empty string is that default value of input
	 * and other form fields in html is empty string, and these fields
	 * will always be empty unless the model already has a value initially.
	 *
	 * @return {udnefined}
	 *
	 */
	setupValidation() {
		if (!this.isValid(this.getInitialValue())) {
			this.props.model.setInvalidProp(this.props.modelProp);
		}
		this.props.model.on('validate:prop', this.triggerFieldValidation, this);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 * @param {String} value
	 *
	 * Prefer the value on the model above the value on the field in some cases when calling
	 * validateProps() directly after modifying the model silently or where for some reason
	 * the value in the field does not correspond to the value on the model.
	 *
	 * @return {Boolean}
	 *
	 */
	shouldPreferModelValue(value) {
		return this.props.model.has(this.props.modelProp) && value !== this.props.model.get(this.props.modelProp);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Get the default/initial value on the model if there is any. If not return
	 * an empty string since this is what the field contains by default. Prefer the value
	 * on the model over the value on the field since this is never used when bluring
	 * the field.
	 *
	 * @return {Mixed} String|*
	 *
	 */
	getInitialValue() {
		const value = (this.shouldRunValidation(this.state.value) ? this.state.value : '') || this.getInitialModelValue();
		if (this.shouldPreferModelValue(value)) {
			return this.getInitialModelValue();
		}
		return value;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * If the model has the prop of the field, return an initial default value.
	 *
	 * @return {Mixed} undefined|*
	 *
	 */
	getInitialModelValue() {
		return this.props.model.has(this.props.modelProp) ? this.props.model.get(this.props.modelProp) : null;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Check to see if we should typeCast the value, everything but null and undefined.
	 *
	 * @param {Mixed} value
	 *
	 * @return {Boolean}
	 */
	shouldTypeCast(value) {
		return value !== null && value !== undefined;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * typeCasts and returns the value if any typeCasting was defined, otherwise
	 * returns the original value.
	 *
	 * @param {String} value
	 *
	 * @return {Mixed}
	 *
	 */
	getModelValue(value) {
		if (this.shouldTypeCast(value) && this.hasTypeCasting()) {
			return this.props.typeCast(value);
		}
		return value;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Formats the value according to a specific formatter if any was
	 * defined, otherwise returns the original value. If the value is
	 * null empty string will be returned since react does not want
	 * your value-prop for regular <input> to be null.
	 *
	 * @param {Mixed} value
	 *
	 * @return {String}
	 *
	 */
	getFieldValue(value) {
		if (this.hasFieldFormatter()) {
			return this.props.format(value);
		}
		return value !== null ? value : '';
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Once a change is detected in the model, update the state of the component (UI)
	 *
	 * @return {undefined}
	 *
	 */
	handleModelChange() {
		this.setState({ value: this.getFieldValue(this.props.model.get(this.props.modelProp)) });
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Once we detect any user input, update the state of the component (UI)
	 * Note, here we only update state, not the model since this event fires once per each
	 * keyevent, we avoid slowdowns because of multiple set operations on the model.
	 *
	 * Always set messages to empty array since only the blur event can generate messages
	 * via isValid() .
	 *
	 * @param {String} value
	 *
	 * @return {undefined}
	 *
	 */
	handleUserInput(value) {
		this.setState({ value, messages: [] });
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Compute the value on the fly, prefer the textbox state over the model since
	 * we update the textbox more often than the model (onChange) fires on each
	 * key event. Always return a string (Could otherwise be null or undefined),
	 * those should be represented as empty strings.
	 *
	 * @return {String}
	 *
	 */
	getComputedValue() {
		const value = this.state.value !== null ? this.state.value : this.getFieldValue(this.props.model.get(this.props.modelProp));
		return (value !== null || value !== undefined) ? value : '';
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Check if the component of this mixin has type casting defined
	 *
	 * @return {Boolean}
	 *
	 */
	hasTypeCasting() {
		return this.props.hasOwnProperty('typeCast');
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Check if the component of this mixin has data formatting options defined
	 *
	 * @return {Boolean}
	 *
	 */
	hasFieldFormatter() {
		return this.props.hasOwnProperty('format');
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Check if the field is empty
	 *
	 * @param {String} value
	 *
	 * @return {Boolean}
	 *
	 */
	isEmptyField(value) {
		return (_.isString(value) && value.length === 0);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Once we detect any user blur event, update the value of the model,
	 * and the state of the component.
	 *
	 * @param {String} value
	 *
	 * @return {undefined}
	 *
	 */
	handleUserBlur(value) {
		this.setState({
			value: this.getFieldValue(value),
			isValid: (this.isEmptyField(value) && !this.props.required)
		});
		if (!this.props.validateOnBlur) {
			return null;
		}
		if (this.runValidators(this.getValidators(), value)) {
			return this.props.onModelSync(this.props.model, this.props.modelProp, this.getModelValue(value));
		}
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Triggered via "validate:prop" on the model. Will only run the validators
	 * if the model prop matches the prop that the field is bound to via databinidng.
	 *
	 * @param {Array} exclude Array of props to exclude from validation
	 * @return {undefined}
	 *
	 */
	triggerFieldValidation(exclude) {
		if (exclude.indexOf(this.props.modelProp) !== -1) { return; }
		this.resetValidationMessages();
		this.runValidators(this.getValidators(), this.getInitialValue());
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Checks if this field is specified as being required, if so
	 * we run the required validation to see if we have any value.
	 *
	 * @param {String} value
	 *
	 * @return {Mixed} Boolean|String
	 *
	 */
	validateRequiredField(value) {
		const hasRequired = this.props.required;
		const hasValue = (_.isString(value) && value.length > 0 || _.isNumber(value) || _.isBoolean(value));
		return (function () {
			if (!hasRequired) { return true; }
			return hasValue ? true : gettext`Detta fält får inte vara tomt`;
		}());
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Runs custom validation on this field if there is any.
	 *
	 * @param {String} value
	 *
	 * @return {Mixed} Boolean|String
	 */
	validateCustomField(value) {
		return this.props.validate ? this.props.validate(value) : true;
	}


	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Generates a list of validators to be used for this field
	 *
	 * @return {Array}
	 *
	 */
	getValidators() {
		const v = [
			{
				fn: this.validateRequiredField.bind(this),
				type: 'internal'
			},
			{
				fn: this.validateCustomField.bind(this),
				type: 'internal'
			}

		];
		if (this.hasModelValidator()) {
			v.push({
				fn: this.props.model.validators[this.props.validator].bind(this.props.model),
				type: 'external'
			});
		}
		return v;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Returns an array of all failed validations (Error messages)
	 * Updates the current state based on these validations, having nothing in the
	 * array means we passed validation. Note that we run the value through
	 * getModelValue(value) since this method takes care of typecasting
	 * if there is any.
	 *
	 * @param {Array} validators
	 * @param {String} value
	 *
	 *
	 * @return {Array}
	 *
	 */
	runValidators(validators, value) {
		let validationResult = [];

		if (!this.shouldRunValidation(value)) {
			// If validation should not be called, the model can't be invalid (the field is empty and not required)
			this.props.model.unsetInvalidProp(this.props.modelProp);
			return validationResult;
		}

		validationResult = this.getValidationArray(validators, value);
		const isValid = validationResult.length === 0;

		this.setModelValidity(isValid);
		this.setState({
			isValid,
			messages: validationResult
		});

		return validationResult;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Updates the list of props and statuses with the prop associated
	 * to this specific field/instance and its valid state.
	 *
	 * @param {Boolean} isValid current state of the field
	 *
	 * @return {Array}
	 *
	 */
	setModelValidity(isValid) {
		if (isValid) {
			return this.props.model.unsetInvalidProp(this.props.modelProp);
		}
		return this.props.model.setInvalidProp(this.props.modelProp);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Check if the model
	 *
	 *
	 * @return {void}
	 *
	 */
	isEmptyModelProp() {
		const value = this.props.model.get(this.props.modelProp);
		const isEmptyString = (_.isString(value) && value.length === 0);
		const isNull = (value === null);
		const isUndefined = (value === undefined);
		return (isEmptyString || isNull || isUndefined);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Reset any dangling validation messages before
	 * rerunning the validation. Incase the model is empty
	 * the validators wont run, in this case previous messages
	 * should be erased.
	 *
	 *
	 * @return {void}
	 *
	 */
	resetValidationMessages() {
		if (this.state.messages.length === 0 || !this.isEmptyModelProp()) {
			return;
		}
		this.setState({ messages: [] });
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * If the component instance has any custom validator
	 * this will return true.
	 *
	 * @param {Object} validator
	 *
	 * @return {Boolean}
	 *
	 */
	isCustomValidator(validator) {
		return validator.hasOwnProperty('external');
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Returns an array containing all failed validations
	 * in the form of strings (messages). If all validation
	 * passes the length of the array will be 0.
	 *
	 * If there is a custom/external validator, then pass the value through typeCasting (getModelValue)
	 * before running the validator.
	 *
	 * @param {Array} validators
	 * @param {String} value
	 *
	 *
	 * @return {Array}
	 *
	 */
	getValidationArray(validators, value) {
		return validators.map(
			validator => this.isCustomValidator(validator) ? validator.fn(this.getModelValue(value)) : validator.fn(value)
		).filter(v => _.isString(v));
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 * Only run validation if the field is not empty
	 * or if the field is required
	 *
	 * @param {Mixed} value
	 * @return {Boolean}
	 *
	 */
	shouldRunValidation(value) {
		const isNullValue = !value && !_.isString(value);
		const isNotRequired = !this.props.required;

		if ((isNullValue && isNotRequired) ||
			this.props.disabled ||
			(this.isEmptyField(value) && isNotRequired)) {
			return false;
		}
		return true;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Check if any specific validator was defined and if that validator exists on the model
	 *
	 * @return {Boolean}
	 *
	 */
	hasModelValidator() {
		const model = this.props.model;
		return this.props.hasOwnProperty('validator') && model.validators && model.validators.hasOwnProperty(this.props.validator);
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 *
	 * Validate the value using any specific field validation and
	 * any validator from the model. If there is no state yet and
	 * the field is not required, then skip validation.
	 *
	 * @param {String} value
	 *
	 * @return {Boolean}
	 *
	 */
	isValid(value) {
		if (!this.shouldRunValidation(value)) {
			return true;
		}
		return this.getValidationArray(this.getValidators(), value).length === 0;
	}

	/**
	 * @private
	 * @memberOf TextBox
	 *
	 * @description
	 * Generate a label tag containing a text above the field, this it based
	 * on the title attribute.
	 *
	 * @return {Object}
	 *
	 */
	getTitle() {
		const title = this.props.hasOwnProperty('title') ? this.props.title : '';
		return <label>{title}{this.props.children}</label>;
	}

	render() {
		return (
			<div className="field-container">
				{this.getTitle()}
				<TextFieldNode
					value={this.getComputedValue()}
					maxlength={this.props.maxlength}
					disabled={this.props.disabled}
					autoFocus={this.props.autoFocus}
					onUserInput={this.handleUserInput.bind(this)}
					onUserBlur={this.handleUserBlur.bind(this)}
					onUserFocus={this.props.onUserFocus}
					isValid={this.state.isValid}
					className={this.props.className}
					tooltipAlign={this.props.tooltipAlign}
					tooltip={this.props.tooltip}
					type={this.props.type}
					placeholder={this.props.placeholder}
					messages={this.state.messages}
					autoComplete={this.props.autoComplete}
				/>
			</div>
		);
	}


}


TextBox.defaultProps = {
	maxLength: 100,
	validateOnBlur: true,
	onUserFocus: () => null,
	onModelSync(model, modelProp, value) {
		return model.set(modelProp, value);
	},
	autoComplete: null
};

TextBox.propTypes = {
	model: customPropTypes.model,
	modelProp: PropTypes.string.isRequired,
	type: PropTypes.string,
	onUserFocus: PropTypes.func,
	onModelSync: PropTypes.func.isRequired,
	maxlength: PropTypes.number,
	disabled: PropTypes.bool,
	autoFocus: PropTypes.bool,
	className: PropTypes.string,
	tooltipAlign: PropTypes.string,
	tooltip: PropTypes.string,
	format: PropTypes.func,
	validate: PropTypes.func,
	validator: PropTypes.string,
	title: PropTypes.string,
	required: PropTypes.bool,
	typeCast: PropTypes.func,
	placeholder: PropTypes.string,
	validateOnBlur: PropTypes.bool,
	autoComplete: PropTypes.oneOf([
		'on',
		'off'
	])
};


export default TextBox;
